<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="node_modules/@xterm/xterm/css/xterm.css" />
    <style>
      body { margin:0; display:flex; height:100vh; font-family:sans-serif; }
      #left { width:320px; padding:12px; border-right:1px solid #ddd; box-sizing:border-box; }
      #right { flex:1; position:relative; overflow:hidden; }
      #term { position:absolute; inset:0; background:#0f111a; }
      label { display:block; font-size:12px; margin-top:8px; }
      input, select { width:100%; box-sizing:border-box; }
      ul { list-style:none; padding:0; margin:0; height:180px; overflow:auto; border-top:1px solid #eee; }
    </style>
  </head>
  <body>
    <div id="left">
      <div style="display:flex; gap:8px; margin-bottom:8px">
        <button id="new-ssh">+ SSH</button>
        <button id="new-sftp">+ SFTP</button>
      </div>
      <h3>Sessions</h3>
      <ul id="sessions"></ul>
    </div>
    <div id="right"><div id="term"></div></div>
    <script src="node_modules/@xterm/xterm/lib/xterm.js"></script>
    <script>
      const term = new Terminal({ cursorBlink:true, theme:{ background:'#0f111a', foreground:'#e6e6e6' } })
      term.open(document.getElementById('term'))
      term.focus()
      let currentId = null
      window.api.sshOnData(payload => {
        try {
          if (typeof payload === 'string') { term.write(payload); return }
          if (payload && payload.id === currentId) { term.write(payload.data) }
        } catch {}
      })
      term.onData(data => { if (currentId != null) window.api.sshSendId(currentId, data) })
      function resize() {
        const rect = document.getElementById('term').getBoundingClientRect()
        const cw = 9; const ch = 18; // rough; good enough for POC
        const cols = Math.max(20, Math.floor(rect.width / cw))
        const rows = Math.max(5, Math.floor(rect.height / ch))
        if (currentId != null) window.api.sshResizeId(currentId, cols, rows)
      }
      window.addEventListener('resize', resize)

      // New session windows
      document.getElementById('new-ssh').onclick = async () => { await window.api.openSessionWindow('SSH'); refreshSessions() }
      document.getElementById('new-sftp').onclick = async () => { await window.api.openSessionWindow('SFTP'); refreshSessions() }

      // Sessions persistence
      async function refreshSessions() {
        const res = await window.api.sessionsLoad()
        const list = document.getElementById('sessions')
        list.innerHTML = ''
        if (!res || !res.sessions) return
        res.sessions.forEach((s, idx) => {
          const li = document.createElement('li')
          const btn = document.createElement('button')
          btn.textContent = `${s.type || 'SSH'} ${s.username}@${s.host}:${s.port}`
          btn.onclick = async () => {
            try {
              currentId = idx
              const cfg = Object.assign({}, s, { id: idx })
              await window.api.sshConnect(cfg)
              await window.api.sshOpenPtyId(idx)
              resize()
              try { await window.api.sftpConnect(cfg) } catch {}
              term.write('\r\n[Connected]\r\n')
            } catch (e) { alert('Connect error: ' + (e?.message||e)) }
          }
          const del = document.createElement('button')
          del.textContent = 'âœ•'
          del.style.marginLeft = '6px'
          del.onclick = async () => { await window.api.sessionsDelete(idx); refreshSessions() }
          li.appendChild(btn); li.appendChild(del)
          list.appendChild(li)
        })
      }
      refreshSessions()
      window.api.onSessionsUpdated(() => refreshSessions())


      // Removed inline auth/SFTP UI
    </script>
  </body>
  </html>
