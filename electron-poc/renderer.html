<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="node_modules/@xterm/xterm/css/xterm.css" />
    <style>
      html, body { height:100%; overflow:hidden; }
      body { margin:0; display:flex; height:100vh; font-family:sans-serif; }
      a, button, input, select, .tab, .left-tab { cursor: pointer }
      #left { width:290px; min-width:180px; max-width:60vw; display:flex; flex-direction:column; padding:0; border-right:1px solid #1f2330; box-sizing:border-box; background:#0b0d14; color:#cfd3dc; transition: width .22s ease, border-right-color .22s ease; }
      #left.no-transition { transition: none !important }
      #left[data-collapsed="1"] { overflow:hidden; border-right-color: transparent; min-width:0 !important }
      #left[data-collapsed="1"] #left-header, #left[data-collapsed="1"] #tree { display:none }
      #left.animating { min-width:0 !important }
      /* Splitter between left and right */
      #splitter { width:8px; cursor: default; background:linear-gradient(180deg,#1e2333,#131726); position: relative; border-left:1px solid #2a3040; border-right:1px solid #2a3040; }
      #splitter:hover { background:linear-gradient(180deg,#262c40,#171b2b); border-left-color:#3a4160; border-right-color:#3a4160 }
      #splitter::after { content:none }
      #splitter .splitter-btn { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(180deg,#1e2333,#131726); border:1px solid #2a3040; border-radius:50%; color:#cfd3dc; width:12px; height:12px; display:none; align-items:center; justify-content:center; padding:0; cursor:pointer; box-shadow:0 4px 14px rgba(0,0,0,.45); z-index:5 }
      #splitter .splitter-btn:hover { background:linear-gradient(180deg,#262c40,#171b2b); border-color:#3a4160 }
      #splitter .splitter-btn svg { display:block }
      /* Set document title to app name */
      /* Title also set from main, but ensure consistency */
      #left-topnav { padding:6px 0px 6px 0px; border-bottom:1px solid #1f2330; display:flex; gap:6px; align-items:center; margin-left: 0; }
      .left-tab { cursor:pointer; padding:6px 10px; border-radius:8px; border:1px solid #2a3040; color:#cfd3dc; background:#1a1f2d; display:flex; align-items:center; gap:6px; margin:0; }
      .left-tab:hover { background:#22283a; }
      #left-header { padding:10px 12px; border-bottom:1px solid #1f2330; font-weight:600; letter-spacing:0.2px; }
      .tree { flex:1; overflow:auto; padding:6px 4px; }
      .item { user-select:none; display:flex; align-items:center; gap:6px; padding:4px 8px; border-radius:6px; cursor: default; position:relative; transition: background .15s ease, transform .12s ease, box-shadow .15s ease; }
      .item:hover { background:#121623; transform: translateX(2px); }
      .item.folder { cursor:pointer }
      .item.session:hover { cursor:pointer }
      .item.selected { background:#1a1f2d; outline:1px solid #2a3040; }
      .item.copied { background:#1a2d1a; outline:1px solid #2fbf71; }
      .item.copied:hover { background:#1f3a1f; }
      .item.cut { background:#2d1a1a; outline:1px solid #bf2f2f; opacity:0.7; }
      .item.cut:hover { background:#3a1f1f; }
      .no-selection .item.selected { background:transparent !important; outline:none !important; }
      .item .icon svg, .item .label { transition: color .15s ease, fill .15s ease, opacity .15s ease; }
      .item:hover .icon svg { fill:#aab0c0 }
      .item:hover .label { color:#e6e6e6 }
      /* Mouse-follow highlight */
      .item::after { content:""; position:absolute; inset:0; pointer-events:none; opacity:0; background: radial-gradient(120px circle at var(--mx, -20px) var(--my, -20px), rgba(255,255,255,.08), transparent 40%); transition: opacity .18s ease; border-radius:6px; }
      .item:hover::after { opacity:1 }
      /* Colored folders and nested sessions in tree */
      .item[data-color] { --tree-color: var(--tree-color, #0b0d14); background: var(--tree-color); }
      .item[data-color]:hover { background: color-mix(in srgb, var(--tree-color) 92%, #ffffff 8%); }
      .item[data-color].selected { background: color-mix(in srgb, var(--tree-color) 85%, #ffffff 15%); outline-color: transparent; }
      .caret { width:0; height:0; border-left:4px solid transparent; border-right:4px solid transparent; border-top:6px solid #8b90a0; transform:rotate(-90deg); transition:transform .15s ease; margin-right:2px; }
      .expanded > .caret { transform:rotate(0deg); }
      .icon { width:14px; height:14px; display:inline-block; }
      .icon svg { width:14px; height:14px; display:block; fill:#8b90a0 }
      .label { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; flex:1; }
      .children { margin-left:16px; }
      .ctx-menu { position:fixed; z-index:1000; background:#0f111a; border:1px solid #2a3040; border-radius:8px; padding:6px 0; min-width:180px; box-shadow:0 6px 18px rgba(0,0,0,.4); }
      .ctx-item { padding:6px 12px; cursor:pointer; }
      .btn, .icon-btn, .left-tab, .ctx-item { cursor: pointer }
      .ctx-item:hover { background:#1a1f2d; }
      .drop-target { outline:1px dashed #3a4160; background:#141a29; }
      #right { flex:1; display:flex; flex-direction:column; min-width:0; min-height:0; }
      #tabs { height:36px; background:#0b0d14; color:#cfd3dc; border-bottom:1px solid #1f2330; display:flex; align-items:flex-end; gap:6px; padding:0 8px; box-sizing:border-box; }
      .tab { cursor: pointer; padding:4px 7px; background:#1a1f2d; border:1px solid #2a3040; border-bottom:none; border-radius:6px 6px 0 0; color:#cfd3dc; max-width:174px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; position:relative; transition:background .15s ease, color .15s ease, border-color .15s ease, box-shadow .15s ease; display:flex; align-items:center; }
      .tab:hover { background:#22283a; border-color:#3a4160; }
      .tab.active { background:#0b0d14; color:#ffffff; border-color:#3a4160; box-shadow:0 0 0 1px #3a4160 inset; font-weight:600; }
      .tab.active::after { content:""; position:absolute; left:8px; right:8px; bottom:-1px; height:3px; border-radius:3px 3px 0 0; background:linear-gradient(90deg,#2f66ef,#7a5cf0); }
      .tab .title { pointer-events:none; flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; }
      .tab .close { margin-left:8px; color:#8b90a0; opacity:.8; display:inline-flex; align-items:center; justify-content:center; width:18px; height:18px; border-radius:50%; transition:background .15s ease, color .15s ease, opacity .15s ease, box-shadow .15s ease; cursor:pointer; }
      .tab .close { flex: 0 0 auto }
      .tab:hover .close { opacity:.95; color:#a0a6b8; }
      .tab .close:hover { color:#e6e6e6; background:#2a3040; opacity:1; box-shadow:0 0 0 2px rgba(58,65,96,.35) inset; }

      /* Colored tabs */
      .tab[data-color] {
        --tab-color-fallback: #0b0d14;
        --tab-color: var(--tab-color, var(--tab-color-fallback));
        background: var(--tab-color);
        border-color: transparent;
      }
      .tab[data-color]:hover { background: color-mix(in srgb, var(--tab-color) 92%, #ffffff 8%); border-color: transparent; }
      .tab[data-color].active { background: color-mix(in srgb, var(--tab-color) 85%, #ffffff 15%); color:#ffffff; border-color: transparent; box-shadow: none; }
      .tab[data-color]::before { content:none; display:none; }
      .tab[data-color].active::after { background: var(--tab-color); }
      #panes { position:relative; flex:1; overflow:hidden; background:#0f111a; min-height:0; }
      .pane { position:absolute; inset:0; display:none; }
      .pane.active { display:block; }

      /* SFTP panel split */
      #sftp-panel { position:relative; flex:1; display:none; background:#0f111a; color:#cfd3dc; }
      #sftp-split { position:absolute; inset:0; display:flex; gap:0; }
      #sftp-local, #sftp-remote { flex:1; display:flex; flex-direction:column; min-width:0; }
      .sftp-controls { display:flex; gap:8px; padding:8px; border-bottom:1px solid #1f2330; align-items:center; }
      .sftp-controls .input { width:100%; max-width:480px; }
      .sftp-list { flex:1; overflow:auto; padding:8px; }
      .sftp-row { display:flex; gap:10px; padding:6px 8px; border-radius:6px; cursor:default; align-items:center; }
      .sftp-row:hover { background:#121623; }
      .sftp-name { flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
      .sftp-type { width:64px; text-transform:uppercase; color:#8b90a0; font-size:12px; text-align:right; overflow:hidden; }

      /* Tunneling placeholder */
      #tun-panel { position:relative; flex:1; display:none; background:#0f111a; color:#cfd3dc; padding:12px; }
      #tun-controls { display:flex; gap:8px; margin-bottom:10px; align-items:center }
      .tun-dot { display:inline-block; width:8px; height:8px; border-radius:50%; background:#2fbf71; margin-left:6px }
      @keyframes pulse { 0% { opacity:.5; transform:scale(1) } 50% { opacity:1; transform:scale(1.3) } 100% { opacity:.5; transform:scale(1) } }
      .tun-dot.active { animation:pulse 1.2s ease-in-out infinite }
      .icon-btn { background:transparent; border:1px solid #2a3040; border-radius:8px; padding:6px; cursor:pointer; color:#cfd3dc }
      .icon-btn:hover { background:#22283a }
      .spin { animation:spin 1s linear infinite }
      @keyframes spin { from { transform:rotate(0) } to { transform:rotate(360deg) } }
      #tun-list { border-top:1px solid #1f2330; padding-top:8px }
      .tun-row { display:flex; gap:10px; padding:6px 8px; border-radius:6px; align-items:center }
      .tun-row:hover { background:#121623 }
      .tun-col { flex:1 }
      .tun-col.small { width:120px; flex:none; color:#8b90a0; font-size:12px }
      /* Ensure xterm fully occupies the pane without causing internal scroll splits */
      .pane > .xterm { width:100% !important; height:100% !important; }
      .pane > .xterm .xterm-viewport { width:100% !important; height:100% !important; }
      /* Modal */
      .modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,.55); display:flex; align-items:center; justify-content:center; z-index:2000; }
      .modal { width:380px; max-width:90vw; background:#0b0d14; color:#cfd3dc; border:1px solid #1f2330; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.5); }
      .modal-header { padding:12px 14px; border-bottom:1px solid #1f2330; font-weight:600; }
      .modal-body { padding:14px; display:flex; flex-direction:column; gap:10px; }
      .modal-actions { padding:12px 14px; border-top:1px solid #1f2330; display:flex; gap:8px; justify-content:flex-end; }
      .input { background:#121623; color:#e6e6e6; border:1px solid #2a3040; border-radius:8px; padding:8px 10px; outline:none; }
      .input:focus { border-color:#3a4160; box-shadow:0 0 0 3px rgba(42,48,64,.35); }
      .btn { background:#1a1f2d; color:#e6e6e6; border:1px solid #2a3040; padding:8px 12px; border-radius:8px; cursor:pointer; }
      .btn:hover { background:#22283a; }
      .btn.primary { background:#2a5bd7; border-color:#2a5bd7; }
      .btn.primary:hover { background:#2f66ef; }
      label { display:block; font-size:12px; margin-top:8px; }
      input, select { width:100%; box-sizing:border-box; }
      ul { list-style:none; padding:0; margin:0; height:180px; overflow:auto; border-top:1px solid #eee; }
      /* Scrollbars */
      .tree::-webkit-scrollbar, .sftp-list::-webkit-scrollbar, body::-webkit-scrollbar, .xterm-viewport::-webkit-scrollbar { width:10px; height:10px }
      .tree::-webkit-scrollbar-track, .sftp-list::-webkit-scrollbar-track, body::-webkit-scrollbar-track, .xterm-viewport::-webkit-scrollbar-track { background:#0b0d14 }
      .tree::-webkit-scrollbar-thumb, .sftp-list::-webkit-scrollbar-thumb, body::-webkit-scrollbar-thumb, .xterm-viewport::-webkit-scrollbar-thumb { background:#2a3040; border-radius:8px; border:2px solid #0b0d14 }
      .tree::-webkit-scrollbar-thumb:hover, .sftp-list::-webkit-scrollbar-thumb:hover, body::-webkit-scrollbar-thumb:hover, .xterm-viewport::-webkit-scrollbar-thumb:hover { background:#3a4160 }
    </style>
  </head>
  <body>
    <div id="left">
      <div id="left-topnav">
        <div id="left-ssh" class="left-tab"><span class="icon"><svg viewBox="0 0 24 24"><path d="M3 12l4-4 4 4-4 4-4-4zm10-2h8v4h-8v-4z"/></svg></span>SSH</div>
        <div id="left-sftp" class="left-tab"><span class="icon sftp"><svg viewBox="0 0 24 24"><path d="M4 4h16v2H4V4zm0 4h10v2H4V8zm0 4h16v2H4v-2zm0 4h10v2H4v-2z"/></svg></span>SFTP</div>
        <div id="left-tun" class="left-tab"><span class="icon"><svg viewBox="0 0 24 24"><path d="M4 11h16v2H4v-2zm3-5h10v2H7V6zm0 10h10v2H7v-2z"/></svg></span>Tunneling</div>
      </div>
      <div id="left-header">Sessions</div>
      <div id="tree" class="tree"></div>
      <div id="ctx" class="ctx-menu" style="display:none"></div>
    </div>
    <div id="splitter" title="Drag to resize sidebar"><button id="splitter-toggle" class="splitter-btn" title="Toggle sidebar" aria-label="Toggle sidebar"></button></div>
      <div id="right">
      <div id="tabs"></div>
      <div id="panes"></div>
      <div id="sftp-panel">
        <div id="sftp-split">
          <div id="sftp-local">
            <div class="sftp-controls">
              <button id="sftp-local-up" class="btn">Up</button>
              <input id="sftp-local-path" class="input" placeholder="/" value="/" />
              <button id="sftp-local-refresh" class="btn">Refresh</button>
            </div>
            <div id="sftp-local-list" class="sftp-list"></div>
          </div>
          <div id="sftp-remote">
            <div class="sftp-controls">
              <button id="sftp-remote-up" class="btn">Up</button>
              <input id="sftp-remote-path" class="input" placeholder="/" value="/" />
              <button id="sftp-remote-refresh" class="btn">Refresh</button>
            </div>
            <div id="sftp-remote-list" class="sftp-list"></div>
          </div>
        </div>
      </div>
      <div id="tun-panel">
        <div id="tun-controls">
          <button id="tun-create" class="btn primary">Create Tunnel</button>
        </div>
        <div id="tun-list"></div>
      </div>
    </div>
    <script src="node_modules/@xterm/xterm/lib/xterm.js"></script>
    <script src="node_modules/@xterm/addon-fit/lib/addon-fit.js"></script>
    <script>
      const terminals = new Map() // id -> { term, el }
      const tabs = new Map() // id -> tab element
      const panesEl = document.getElementById('panes')
      const tabsEl = document.getElementById('tabs')
      let currentId = null
      let draggingId = null
      const THEME_BASE = '#0b0d14'
      const THEME_ACCENT = '#2a5bd7'
      const DEFAULT_FOLDER_COLOR = THEME_BASE
      const ZOOM_STEP = 1
      const ZOOM_MIN = 8
      const ZOOM_MAX = 64
      const zoomGuard = { in:false, out:false, reset:false }

      function closeTabById(id) {
        try {
          const rec = terminals.get(id)
          if (rec) { try { rec.term.dispose() } catch {}; try { rec.el.remove() } catch {}; terminals.delete(id) }
          const t = tabs.get(id)
          if (t) { try { t.remove() } catch {}; tabs.delete(id) }
          if (currentId === id) currentId = null
          const next = [...tabs.keys()][0]
          if (next != null) activateTab(next)
        } catch {}
      }

      function createTerminalFor(id, title) {
        const pane = document.createElement('div')
        pane.className = 'pane'
        panesEl.appendChild(pane)
        const term = new Terminal({ cursorBlink:true, copyOnSelection:true, theme:{ background:'#0f111a', foreground:'#e6e6e6' } })
        const fit = new FitAddon.FitAddon()
        term.loadAddon(fit)
        term.open(pane)
        term.focus()
        const initialFontSize = (() => { try { return Number(term.options && term.options.fontSize) || 15 } catch { return 15 } })()
        const applyZoom = (mode) => {
          try {
            const rec = terminals.get(id)
            const current = (rec && typeof rec.currFontSize === 'number') ? rec.currFontSize : (Number(term.options && term.options.fontSize) || initialFontSize)
            const base = (rec && typeof rec.baseFontSize === 'number') ? rec.baseFontSize : initialFontSize
            let next = current
            if (mode === 'in') next = Math.min(ZOOM_MAX, current + ZOOM_STEP)
            else if (mode === 'out') next = Math.max(ZOOM_MIN, current - ZOOM_STEP)
            else if (mode === 'reset') next = base
            if (next !== current) {
              try { term.options.fontSize = next } catch {}
              if (rec) rec.currFontSize = next
              try { resize() } catch {}
            }
          } catch {}
        }
        // Reliable copy helpers bound to xterm root element and xterm key hook
        let lastSelection = ''
        try {
          term.onSelectionChange?.(() => {
            try { lastSelection = String(term.getSelection() || '') } catch { lastSelection = '' }
          })
        } catch {}
        const performClipboardWrite = async (text) => {
          if (!text) return
          try {
            if (navigator && navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
              await navigator.clipboard.writeText(text)
              return
            }
          } catch {}
          try {
            window.api.copyText(text)
            return
          } catch {}
          try {
            const ta = document.createElement('textarea')
            ta.value = text
            ta.style.position = 'fixed'
            ta.style.left = '-10000px'
            ta.style.top = '-10000px'
            document.body.appendChild(ta)
            ta.focus()
            ta.select()
            try { document.execCommand('copy') } catch {}
            try { document.body.removeChild(ta) } catch {}
          } catch {}
        }
        const clearSelections = () => {
          try { if (typeof term.clearSelection === 'function') term.clearSelection() } catch {}
          try {
            const sel = typeof window.getSelection === 'function' ? window.getSelection() : null
            if (sel && typeof sel.removeAllRanges === 'function') sel.removeAllRanges()
          } catch {}
        }
        const copySelectedText = async () => {
          try {
            let selected = (typeof term.getSelection === 'function') ? (term.getSelection() || '') : ''
            if (!selected && lastSelection) selected = lastSelection
            if (!selected && typeof window.getSelection === 'function') {
              try { selected = String(window.getSelection().toString() || '') } catch {}
            }
            if (selected) { await performClipboardWrite(selected); clearSelections() }
          } catch {}
        }
        const xtermEl = () => (pane && pane.querySelector) ? pane.querySelector('.xterm') : null
        const forceClearSelectionVisual = () => {
          try {
            const el = xtermEl()
            const target = el ? (el.querySelector('.xterm-viewport') || el) : null
            if (!target) return
            const mk = (type) => new MouseEvent(type, { bubbles:true, cancelable:true, button:0, buttons:0, clientX:1, clientY:1 })
            try { target.dispatchEvent(mk('mousedown')) } catch {}
            try { target.dispatchEvent(mk('mouseup')) } catch {}
            try { target.dispatchEvent(mk('click')) } catch {}
          } catch {}
        }
        const collapseInputCaret = () => {
          try {
            const el = xtermEl()
            const ta = el ? el.querySelector('.xterm-helper-textarea') : null
            if (ta && typeof ta.setSelectionRange === 'function') {
              const len = Number(ta.value ? ta.value.length : 0)
              try { ta.setSelectionRange(len, len) } catch {}
            }
          } catch {}
        }
        const clearOsSelectionByDummy = () => {
          try {
            const dummy = document.createElement('span')
            dummy.textContent = '\u200b'
            dummy.style.position = 'fixed'
            dummy.style.left = '-99999px'
            dummy.style.top = '-99999px'
            document.body.appendChild(dummy)
            const range = document.createRange()
            range.selectNodeContents(dummy)
            const sel = window.getSelection && window.getSelection()
            if (sel) { try { sel.removeAllRanges() } catch {}; try { sel.addRange(range) } catch {} }
            try { sel && sel.removeAllRanges && sel.removeAllRanges() } catch {}
            try { document.body.removeChild(dummy) } catch {}
          } catch {}
        }
        const clearXtermSelectionDeep = () => {
          try { if (typeof term.clearSelection === 'function') term.clearSelection() } catch {}
          try { const core = term && (term._core || term._coreProxy || term._coreService); core && core._selectionService && core._selectionService.clearSelection && core._selectionService.clearSelection() } catch {}
          try { clearSelections() } catch {}
          try { forceClearSelectionVisual() } catch {}
          try { clearOsSelectionByDummy() } catch {}
        }
        // Use capture to run even if inner handlers stop propagation
        setTimeout(() => {
          const el = xtermEl()
          if (el) {
            el.addEventListener('contextmenu', async (e) => {
              e.preventDefault()
              // Decide based on actual current selection only (not cached)
              let hasSel = false
              try { hasSel = typeof term.hasSelection === 'function' ? term.hasSelection() : false } catch {}
              if (!hasSel) {
                try {
                  const domSel = typeof window.getSelection === 'function' ? window.getSelection() : null
                  hasSel = Boolean(domSel && String(domSel.toString()||'').length)
                } catch {}
              }
              if (hasSel) {
                await copySelectedText()
                return
              }
              // No selection -> paste from clipboard
              let text = ''
              try {
                if (navigator && navigator.clipboard && typeof navigator.clipboard.readText === 'function') {
                  text = await navigator.clipboard.readText()
                }
              } catch {}
              if (!text) {
                try { text = String(window.api.readText() || '') } catch {}
              }
              if (text) {
                try {
                  if (term.paste) {
                    term.paste(text)
                  } else {
                    window.api.sshSendId(currentId, text)
                  }
                } catch {
                  try { window.api.sshSendId(currentId, text) } catch {}
                } finally {
                  try { lastSelection = '' } catch {}
          const clearCycle = () => { try { clearXtermSelectionDeep() } catch {}; try { collapseInputCaret() } catch {}; try { term.blur?.() } catch {}; try { term.focus() } catch {} }
                  try { clearCycle() } catch {}
                  try { requestAnimationFrame(() => clearCycle()) } catch {}
                  try { setTimeout(() => clearCycle(), 0) } catch {}
                  try { setTimeout(() => clearCycle(), 30) } catch {}
                  try { setTimeout(() => clearCycle(), 100) } catch {}
                  try {
                    const onUp = () => { try { clearCycle() } catch {}; try { document.removeEventListener('mouseup', onUp, true) } catch {} }
                    document.addEventListener('mouseup', onUp, true)
                  } catch {}
                }
              }
            }, { capture: true })
          }
        }, 0)
        // Handle Ctrl+Shift+C via xterm API so events consumed by xterm are still caught
        try {
          term.attachCustomKeyEventHandler((ev) => {
            // Copy
            if ((ev.key === 'c' || ev.key === 'C') && ev.ctrlKey && ev.shiftKey) {
              copySelectedText()
              return false
            }
            // Zoom in/out/reset (guarded per physical press)
            if (ev.ctrlKey) {
              const isPlus = (ev.key === '+' || (ev.key === '=' && ev.shiftKey) || ev.code === 'NumpadAdd')
              const isMinus = (ev.key === '-' || ev.code === 'NumpadSubtract')
              const isReset = (ev.key === '=' && !ev.shiftKey)
              if (isPlus) { if (!zoomGuard.in) { applyZoom('in'); zoomGuard.in = true } return false }
              if (isMinus) { if (!zoomGuard.out) { applyZoom('out'); zoomGuard.out = true } return false }
              if (isReset) { if (!zoomGuard.reset) { applyZoom('reset'); zoomGuard.reset = true } return false }
            }
            return true
          })
        } catch {}
        term.onData(data => { if (currentId != null) window.api.sshSendId(currentId, data) })
        terminals.set(id, { term, el: pane, fit, baseFontSize: initialFontSize, currFontSize: initialFontSize })

        const tab = document.createElement('div')
        tab.className = 'tab'
        tab.title = title
        const titleEl = document.createElement('span')
        titleEl.className = 'title'
        titleEl.textContent = title
        tab.appendChild(titleEl)
        const close = document.createElement('span')
        close.textContent = '✕'
        close.className = 'close'
        close.onclick = async (e) => {
          e.stopPropagation()
          if (currentId === id) { currentId = null }
          try { await window.api.sshDisconnect?.(id) } catch {}
          const rec = terminals.get(id)
          if (rec) { try { rec.term.dispose() } catch {}; rec.el.remove(); terminals.delete(id) }
          const t = tabs.get(id); if (t) { t.remove(); tabs.delete(id) }
          // Activate another tab if any
          const next = [...tabs.keys()][0]
          if (next != null) activateTab(next)
        }
        tab.appendChild(close)
        tab.onclick = () => activateTab(id)
        tab.oncontextmenu = (e) => { e.preventDefault(); openTabCtxMenu(e.clientX, e.clientY, id) }
        tabsEl.appendChild(tab)
        tabs.set(id, tab)
      }

      function createSftpTab(id, title) {
        if (tabs.has(id)) return
        const tab = document.createElement('div')
        tab.className = 'tab'
        tab.title = title
        const titleEl = document.createElement('span')
        titleEl.className = 'title'
        titleEl.textContent = title
        tab.appendChild(titleEl)
        const close = document.createElement('span')
        close.textContent = '✕'
        close.className = 'close'
        close.onclick = async (e) => {
          e.stopPropagation()
          try { await window.api.sftpDisconnect?.(id) } catch {}
          if (currentId === id) currentId = null
          const t = tabs.get(id); if (t) { t.remove(); tabs.delete(id) }
          // Activate another tab if any, otherwise show SSH view baseline
          const next = [...tabs.keys()][0]
          if (next != null) activateTab(next)
          else { showSshView() }
        }
        tab.appendChild(close)
        tab.onclick = () => { activateTab(id); showSftpView() }
        tab.oncontextmenu = (e) => { e.preventDefault(); openTabCtxMenu(e.clientX, e.clientY, id) }
        tabsEl.appendChild(tab)
        tabs.set(id, tab)
      }

      function activateTab(id) {
        currentId = id
        for (const [tid, { el }] of terminals.entries()) { el.classList.toggle('active', tid === id) }
        for (const [tid, tab] of tabs.entries()) { tab.classList.toggle('active', tid === id) }
        if (terminals.has(id)) {
          showSshView()
          const rec = terminals.get(id)
          try { rec?.term?.focus() } catch {}
          resize()
        } else {
          showSftpView()
        }
      }

      // View toggling between SSH (terminal panes) and SFTP panel
      function showSshView() {
        const panes = document.getElementById('panes')
        const tabsBar = document.getElementById('tabs')
        const sftpPanel = document.getElementById('sftp-panel')
        const tunPanel = document.getElementById('tun-panel')
        panes.style.display = 'block'
        tabsBar.style.display = 'flex'
        sftpPanel.style.display = 'none'
        tunPanel.style.display = 'none'
        resize()
      }
      function showSftpView() {
        const panes = document.getElementById('panes')
        const tabsBar = document.getElementById('tabs')
        const sftpPanel = document.getElementById('sftp-panel')
        const tunPanel = document.getElementById('tun-panel')
        panes.style.display = 'none'
        tabsBar.style.display = 'flex'
        sftpPanel.style.display = 'block'
        tunPanel.style.display = 'none'
      }

      // Left top buttons: open session creation modals
      document.getElementById('left-ssh').onclick = async () => {
        try {
          const res = await window.api.openSessionWindow('SSH')
          const s = res && res.session
          if (!s) return
          const node = { id: genId('sess'), type:'session', name: `${s.name||s.host} (${s.username})`, session: s }
          sessionTree.push(node)
          await window.api.sessionsSaveTree(sessionTree)
          saveToHistory() // Save to history after creation
          renderTree()
        } catch (e) { alert('Create SSH session error: ' + (e?.message||e)) }
      }
      document.getElementById('left-sftp').onclick = async () => {
        try {
          const res = await window.api.openSessionWindow('SFTP')
          const s = res && res.session
          if (!s) return
          const node = { id: genId('sess'), type:'session', name: `${s.name||s.host} (${s.username})`, session: s }
          sessionTree.push(node)
          await window.api.sessionsSaveTree(sessionTree)
          saveToHistory() // Save to history after creation
          renderTree()
        } catch (e) { alert('Create SFTP session error: ' + (e?.message||e)) }
      }
      document.getElementById('left-tun').onclick = async () => {
        document.getElementById('sftp-panel').style.display = 'none'
        document.getElementById('panes').style.display = 'none'
        document.getElementById('tabs').style.display = 'flex'
        document.getElementById('tun-panel').style.display = 'block'
      }

      window.api.sshOnData(payload => {
        try {
          if (typeof payload === 'string') {
            const rec = currentId != null ? terminals.get(currentId) : null
            if (rec) rec.term.write(payload)
            return
          }
          const rec = payload && terminals.get(payload.id)
          if (rec) rec.term.write(payload.data)
        } catch {}
      })
      function resize() {
        const active = currentId != null ? terminals.get(currentId) : null
        if (!active) return
        try { active.fit.fit() } catch {}
        if (currentId != null) {
          const term = active.term
          if (term && typeof term.cols === 'number' && typeof term.rows === 'number') {
            window.api.sshResizeId(currentId, term.cols, term.rows)
          }
        }
      }
      window.addEventListener('resize', resize)
      // Sidebar resize + collapse
      ;(function initSidebarResize(){
        const left = document.getElementById('left')
        const splitter = document.getElementById('splitter')
        const STORAGE_KEY = 'sidebar-width'
        const COLLAPSE_KEY = 'sidebar-collapsed'
        let startX = 0
        let startW = 0
        let dragging = false
        function applyWidth(px){
          try {
            const min = 180
            const max = 400 // Fixed maximum width instead of 60% of screen
            if (px <= 24) { setCollapsed(true); return }
            const clamped = Math.max(min, Math.min(max, Math.round(px)))
            left.style.width = clamped + 'px'
            try { localStorage.setItem(STORAGE_KEY, String(clamped)) } catch {}
            try { resize() } catch {}
          } catch {}
        }
        function setCollapsed(collapsed, opts){
          const options = opts || {}
          if (collapsed) {
            const current = Math.round(left.getBoundingClientRect().width)
            left.dataset.collapsed = '1'
            if (options.instant) {
              left.classList.add('no-transition')
              left.style.width = '0px'
              left.offsetHeight; // force reflow
              left.classList.remove('no-transition')
            } else {
              left.classList.add('animating')
              left.style.width = current + 'px'
              requestAnimationFrame(() => { left.style.width = '0px' })
              const onEnd = (ev) => { if (ev && ev.propertyName !== 'width') return; left.removeEventListener('transitionend', onEnd); left.classList.remove('animating') }
              left.addEventListener('transitionend', onEnd)
            }
          } else {
            const target = Number(localStorage.getItem(STORAGE_KEY)||'290') || 290
            if (options.instant) {
              delete left.dataset.collapsed
              left.classList.add('no-transition')
              left.style.width = target + 'px'
              left.offsetHeight; // force reflow
              left.classList.remove('no-transition')
            } else {
              // Animate from 0 -> target while temporarily allowing min-width:0
              left.classList.add('animating')
              left.style.width = '0px'
              requestAnimationFrame(() => { 
                delete left.dataset.collapsed; 
                left.style.width = target + 'px'
                // Update UI after dataset is updated
                setTimeout(() => updateToggleUI(), 10)
              })
              const onEnd2 = (ev) => { if (ev && ev.propertyName !== 'width') return; left.removeEventListener('transitionend', onEnd2); left.classList.remove('animating') }
              left.addEventListener('transitionend', onEnd2)
            }
          }
          try { localStorage.setItem(COLLAPSE_KEY, collapsed?'1':'0') } catch {}
          try { resize() } catch {}
          // updateToggleUI() is called separately for animated case above
          if (collapsed) {
            try { updateToggleUI() } catch {}
          }
        }
        function updateToggleUI(){
          const splitBtn = document.getElementById('splitter-toggle')
          const isCollapsed = left.dataset.collapsed==='1'
          console.log('updateToggleUI: isCollapsed =', isCollapsed, 'dataset.collapsed =', left.dataset.collapsed)
          if (splitBtn) {
            splitBtn.style.display = 'flex' // Always show the button
            splitBtn.innerHTML = isCollapsed
              ? '<span style="color: #cfd3dc; font-size: 10px;">→</span>'
              : '<span style="color: #cfd3dc; font-size: 10px;">←</span>'
            splitBtn.title = isCollapsed ? 'Show sidebar' : 'Hide sidebar'
          }
        }
        // Restore state
        try {
          const saved = Number(localStorage.getItem(STORAGE_KEY)||'0')
          // Force new width - always set to 290px
          left.style.width = '290px'
          localStorage.setItem(STORAGE_KEY, '290')
          // Always start with sidebar open (not collapsed)
          delete left.dataset.collapsed
          // Ensure button reflects state immediately on first paint
          requestAnimationFrame(() => {
            updateToggleUI()
          })
        } catch { updateToggleUI() }
        // Dragging disabled - only toggle button works
        // splitter.addEventListener('mousedown', (e)=>{
        //   if (e.button!==0) return
        //   // Don't start drag when clicking the toggle button
        //   const isOnButton = e.target && e.target.closest && e.target.closest('.splitter-btn')
        //   if (isOnButton) return
        //   dragging = true
        //   startX = e.clientX
        //   const isCollapsed = left.dataset.collapsed==='1'
        //   if (isCollapsed) {
        //     // Expand from collapsed on drag
        //     delete left.dataset.collapsed
        //     startW = Number(localStorage.getItem(STORAGE_KEY)||'320') || 320
        //     left.style.width = '1px'
        //   } else {
        //     startW = left.getBoundingClientRect().width
        //   }
        //   left.classList.add('no-transition')
        //   document.body.style.userSelect = 'none'
        // })
        // window.addEventListener('mousemove', (e)=>{
        //   if (!dragging) return
        //   const dx = e.clientX - startX
        //   applyWidth(startW + dx)
        // })
        // window.addEventListener('mouseup', ()=>{
        //   if (!dragging) return
        //   dragging = false
        //   document.body.style.userSelect = ''
        //   left.classList.remove('no-transition')
        // })
        // Double click splitter disabled - only toggle button works
        // splitter.addEventListener('dblclick', ()=>{
        //   const isCollapsed = left.dataset.collapsed==='1'
        //   setCollapsed(!isCollapsed)
        // })
        // Buttons
        try {
          const splitBtn = document.getElementById('splitter-toggle')
          if (splitBtn) splitBtn.onclick = () => { 
            const isCollapsed = left.dataset.collapsed==='1'
            setCollapsed(!isCollapsed) 
          }
        } catch {}
        // Keyboard toggle: Ctrl+B (like VS Code)
        document.addEventListener('keydown', (e)=>{
          if (e.ctrlKey && (e.key==='b' || e.key==='B')) {
            const isCollapsed = left.dataset.collapsed==='1'
            setCollapsed(!isCollapsed)
            e.preventDefault()
            e.stopPropagation()
          }
        })
      })()

      // Tree state and helpers
      let sessionTree = []
      let selectedId = null
      let selectedIds = [] // Array of selected IDs for multi-selection
      let selectedIdStack = []
      let copiedSession = null
      let cutMode = false // true if item was cut, false if copied
      let multiSelectMode = false // true when selecting multiple items
      let copiedFromContext = null // Store the context where items were copied from
      let history = [] // Array to store history of tree states
      let historyIndex = -1 // Current position in history
      const MAX_HISTORY = 50 // Maximum number of history entries
      let isUndoRedoOperation = false // Flag to prevent history reset during undo/redo
      
      // Function to track selectedId changes
      function setSelectedId(newId) {
        selectedId = newId
      }
      
      // Add item to multi-selection
      function addToSelection(id) {
        if (!selectedIds.includes(id)) {
          selectedIds.push(id)
        }
      }
      
      // Remove item from multi-selection
      function removeFromSelection(id) {
        const index = selectedIds.indexOf(id)
        if (index > -1) {
          selectedIds.splice(index, 1)
        }
      }
      
      // Clear all selections
      function clearSelection() {
        selectedId = null
        selectedIds = []
        multiSelectMode = false
        // Don't clear copiedFromContext - we need it for paste operations
      }
      
      // Clear copy state completely
      function clearCopyState() {
        copiedSession = null
        cutMode = false
        copiedFromContext = null
        // Clear all visual indicators
        document.querySelectorAll('.item.copied, .item.cut').forEach(el => {
          el.classList.remove('copied', 'cut')
          el.title = ''
        })
      }
      
      // Save current state to history
      function saveToHistory() {
        const state = JSON.parse(JSON.stringify(sessionTree)) // Deep copy
        historyIndex++
        
        // Remove any states after current index
        history = history.slice(0, historyIndex)
        
        // Add new state
        history.push(state)
        
        // Limit history size
        if (history.length > MAX_HISTORY) {
          history.shift()
          historyIndex--
        }
      }
      
      // Undo last operation
      async function undo() {
        if (historyIndex > 0) {
          historyIndex--
          const previousState = history[historyIndex]
          sessionTree = JSON.parse(JSON.stringify(previousState)) // Deep copy
          await window.api.sessionsSaveTree(sessionTree)
          clearSelection()
          renderTree()
          return true
        }
        return false
      }
      
      // Redo last undone operation
      async function redo() {
        if (historyIndex < history.length - 1) {
          historyIndex++
          const nextState = history[historyIndex]
          sessionTree = JSON.parse(JSON.stringify(nextState)) // Deep copy
          await window.api.sessionsSaveTree(sessionTree)
          clearSelection()
          renderTree()
          return true
        }
        return false
      }
      
      // Check if item is selected
      function isSelected(id) {
        return selectedId === id || selectedIds.includes(id)
      }
      
      // Select range of items between startId and endId
      function selectRange(startId, endId) {
        // Find all items in the tree (flattened)
        const allItems = []
        function collectItems(list, parent = null) {
          list.forEach((item, index) => {
            allItems.push({ ...item, index, parent })
            if (item.children) {
              collectItems(item.children, item)
            }
          })
        }
        collectItems(sessionTree)
        
        // Find start and end positions
        const startIndex = allItems.findIndex(item => item.id === startId)
        const endIndex = allItems.findIndex(item => item.id === endId)
        
        if (startIndex === -1 || endIndex === -1) {
          // If we can't find the items, just add the end item
          addToSelection(endId)
          return
        }
        
        // Clear current selection
        selectedIds.length = 0
        
        // Select all items between start and end (inclusive)
        const minIndex = Math.min(startIndex, endIndex)
        const maxIndex = Math.max(startIndex, endIndex)
        
        for (let i = minIndex; i <= maxIndex; i++) {
          const item = allItems[i]
          if (item.type === 'session' || item.type === 'folder') {
            addToSelection(item.id)
          }
        }
      }
      function genId(prefix='id') { return prefix + '_' + Date.now().toString(36) + Math.random().toString(36).slice(2,7) }
      function findNodeById(list, id, parent=null) {
        for (let i=0;i<list.length;i++) {
          const n = list[i]
          if (n.id === id) return { node:n, index:i, parent }
          if (n.type === 'folder' && Array.isArray(n.children)) {
            const r = findNodeById(n.children, id, n)
            if (r) return r
          }
        }
        return null
      }
      function findParentFolderColor(list, id) {
        const info = findNodeById(list, id, null)
        if (!info) return null
        let p = info.parent
        while (p) {
          if (p.type === 'folder' && typeof p.color === 'string' && p.color) return p.color
          // climb up
          const parentInfo = findNodeById(sessionTree, p.id, null)
          p = parentInfo ? parentInfo.parent : null
        }
        return null
      }
      function removeNodeById(id) {
        const info = findNodeById(sessionTree, id, null)
        if (!info) return false
        if (!info.parent) { sessionTree.splice(info.index, 1) }
        else { info.parent.children.splice(info.index, 1) }
        return true
      }

      // Copy session or folder function
      function copySession(id) {
        const info = findNodeById(sessionTree, id, null)
        if (!info || (info.node.type !== 'session' && info.node.type !== 'folder')) {
          return false
        }
        
        copiedSession = JSON.parse(JSON.stringify(info.node)) // Deep copy
        cutMode = false // Mark as copied, not cut
        copiedFromContext = info.parent ? info.parent.id : null // Store parent context
        setSelectedId(null) // Clear selection after copying
        renderTree() // Update visual indicators and clear selection
        
        return true
      }
      
      // Copy multiple sessions or folders function
      function copyMultipleSessions() {
        if (selectedIds.length === 0) return false
        
        const items = []
        let parentContext = null
        
        for (const id of selectedIds) {
          const info = findNodeById(sessionTree, id, null)
          if (info && (info.node.type === 'session' || info.node.type === 'folder')) {
            items.push(JSON.parse(JSON.stringify(info.node)))
            // Store parent context (assuming all selected items are from the same parent)
            if (parentContext === null) {
              parentContext = info.parent ? info.parent.id : null
            }
          }
        }
        
        if (items.length === 0) return false
        
        copiedSession = items // Store array of items
        cutMode = false // Mark as copied, not cut
        copiedFromContext = parentContext // Store parent context
        clearSelection() // Clear selection after copying
        renderTree() // Update visual indicators and clear selection
        
        return true
      }

      // Cut session or folder function
      function cutSession(id) {
        const info = findNodeById(sessionTree, id, null)
        if (!info || (info.node.type !== 'session' && info.node.type !== 'folder')) {
          return false
        }
        
        copiedSession = JSON.parse(JSON.stringify(info.node)) // Deep copy
        cutMode = true // Mark as cut
        copiedFromContext = info.parent ? info.parent.id : null // Store parent context
        setSelectedId(null) // Clear selection after cutting
        renderTree() // Update visual indicators and clear selection
        
        return true
      }
      
      // Cut multiple sessions or folders function
      function cutMultipleSessions() {
        if (selectedIds.length === 0) return false
        
        const items = []
        let parentContext = null
        
        for (const id of selectedIds) {
          const info = findNodeById(sessionTree, id, null)
          if (info && (info.node.type === 'session' || info.node.type === 'folder')) {
            items.push(JSON.parse(JSON.stringify(info.node)))
            // Store parent context (assuming all selected items are from the same parent)
            if (parentContext === null) {
              parentContext = info.parent ? info.parent.id : null
            }
          }
        }
        
        if (items.length === 0) return false
        
        copiedSession = items // Store array of items
        cutMode = true // Mark as cut
        copiedFromContext = parentContext // Store parent context
        clearSelection() // Clear selection after cutting
        renderTree() // Update visual indicators and clear selection
        
        return true
      }
      
      // Delete multiple sessions or folders function
      async function deleteMultipleSessions() {
        if (selectedIds.length === 0) {
          return false
        }
        
        // Delete all selected items
        for (const id of selectedIds) {
          const info = findNodeById(sessionTree, id, null)
          if (info && (info.node.type === 'session' || info.node.type === 'folder')) {
            // Clear copied session if it's being deleted
            clearCopiedSession(id)
            
            // Remove from tree
            if (info.parent) {
              info.parent.children.splice(info.index, 1)
            } else {
              sessionTree.splice(info.index, 1)
            }
          }
        }
        
        // Save changes
        await window.api.sessionsSaveTree(sessionTree)
        saveToHistory() // Save to history after deletion
        clearSelection() // Clear selection after deletion
        renderTree() // Update tree
        
        return true
      }

      // Paste session or folder function
      async function pasteSession(targetId = null) {
        if (!copiedSession) return false
        
        // Handle both single item and multiple items
        const items = Array.isArray(copiedSession) ? copiedSession : [copiedSession]
        const newItems = items.map(item => generateNewIds(JSON.parse(JSON.stringify(item))))
        
        // Smart naming: only add (Copy) suffix if copying (not cutting) and not pasting into a folder
        let shouldAddCopySuffix = true
        if (cutMode) {
          shouldAddCopySuffix = false // Don't add (Copy) when cutting and pasting
        } else if (targetId) {
          const targetInfo = findNodeById(sessionTree, targetId, null)
          if (targetInfo && targetInfo.node.type === 'folder') {
            shouldAddCopySuffix = false // Don't add (Copy) when pasting into a folder
          }
        } else {
          // If no targetId, we're pasting to root
          // Check if any of the items already have (Copy) suffix
          const hasCopySuffix = newItems.some(item => {
            if (!item.name) return false
            // Check if name ends with (Copy) or contains multiple (Copy) suffixes
            return item.name.endsWith(' (Copy)') || item.name.includes(' (Copy) (Copy)')
          })
          if (hasCopySuffix) {
            shouldAddCopySuffix = false // Don't add (Copy) if items already have it
          } else {
            shouldAddCopySuffix = true // Add (Copy) for first-time copying to root
          }
        }
        
        // Apply naming to all items
        newItems.forEach(newNode => {
          if (shouldAddCopySuffix) {
            // Only add (Copy) if the item doesn't already have it
            if (!newNode.name || (!newNode.name.endsWith(' (Copy)') && !newNode.name.includes(' (Copy) (Copy)'))) {
              newNode.name = (newNode.name || '') + ' (Copy)'
            }
          }
        })
        
        let targetContainer = sessionTree
        let insertIndex = sessionTree.length
        
        if (targetId) {
          const targetInfo = findNodeById(sessionTree, targetId, null)
          if (targetInfo) {
            if (targetInfo.node.type === 'folder') {
              targetContainer = targetInfo.node.children || (targetInfo.node.children = [])
              targetInfo.node.expanded = true
              insertIndex = targetContainer.length
            } else {
              // Insert after the target session
              const parent = targetInfo.parent
              targetContainer = parent ? parent.children : sessionTree
              insertIndex = targetInfo.index + 1
            }
          }
        }
        
        // Insert all items
        targetContainer.splice(insertIndex, 0, ...newItems)
        
        // If this was a cut operation, remove the original items
        if (cutMode) {
          for (const item of items) {
            const originalInfo = findNodeById(sessionTree, item.id, null)
            if (originalInfo) {
              removeNodeById(item.id)
            }
          }
        }
        
        await window.api.sessionsSaveTree(sessionTree)
        saveToHistory() // Save to history after paste
        renderTree()
        
        // Clear copy state after successful paste
        clearCopyState()
        // Force re-render to clear visual indicators
        setTimeout(() => {
          renderTree()
        }, 0)
        return true
      }

      // Generate new IDs for all elements in a folder (recursive)
      function generateNewIds(node) {
        if (!node) return node
        const newNode = { ...node }
        newNode.id = genId(node.type === 'folder' ? 'fld' : 'sess')
        
        if (node.type === 'folder' && node.children) {
          newNode.children = node.children.map(child => generateNewIds(child))
        }
        
        return newNode
      }

      // Clear copied session when it's deleted or modified
      function clearCopiedSession(id) {
        if (copiedSession) {
          if (Array.isArray(copiedSession)) {
            // Check if any item in the array matches the id
            const hasItem = copiedSession.some(item => item.id === id)
            if (hasItem) {
              clearCopyState()
              renderTree()
            }
          } else if (copiedSession.id === id) {
            clearCopyState()
            renderTree()
          }
        }
      }

      function renderTree() {
        const root = document.getElementById('tree')
        root.innerHTML = ''
        // enable dropping to root to move to top level
        root.addEventListener('dragover', (e) => { e.preventDefault() })
        root.addEventListener('drop', async (e) => {
          e.preventDefault()
          // If dropping on an item subtree, let the item's handler manage it
          if (e.target && e.target.closest && e.target.closest('.item')) return
          if (!draggingId) return
          await moveNode(draggingId, { id:'__root__', type:'folder' })
          draggingId = null
        })
        // Clear selection when clicking on empty space in the tree
        root.onclick = (e) => {
          const t = e && e.target
          if (t && t.closest && t.closest('.item')) return
          if (selectedId != null) {
            setSelectedId(null)
            try { hideCtx() } catch {}
            renderTree()
          }
        }

        function renderList(list, container, inheritedColor) {
          list.forEach(n => {
            const row = document.createElement('div')
            const itemSelected = isSelected(n.id)
            let isCut = false
            let isCopied = false
            
            if (copiedSession) {
              if (Array.isArray(copiedSession)) {
                isCut = cutMode && copiedSession.some(item => item.id === n.id)
                isCopied = !cutMode && copiedSession.some(item => item.id === n.id)
              } else {
                isCut = cutMode && copiedSession.id === n.id
                isCopied = !cutMode && copiedSession.id === n.id
              }
            }
            row.className = 'item ' + (n.type==='folder'?'folder':'session') + (n.expanded ? ' expanded' : '') + (itemSelected ? ' selected' : '') + (isCut ? ' cut' : '') + (isCopied ? ' copied' : '')
            row.dataset.id = n.id
            row.draggable = true
            const effectiveColor = n.type === 'folder' ? (n.color || inheritedColor) : inheritedColor
            if (effectiveColor) { row.dataset.color = '1'; row.style.setProperty('--tree-color', effectiveColor) } else { delete row.dataset.color; row.style.removeProperty('--tree-color') }
            
            // Add visual indicator for copied session or folder
            if (copiedSession && copiedSession.id === n.id) {
              row.classList.add('copied')
              const itemType = n.type === 'folder' ? 'folder' : 'session'
              row.title = `Copied ${itemType} - ready to paste`
            }
            const caret = document.createElement('div')
            caret.className = 'caret'
            caret.style.visibility = n.type==='folder' ? 'visible' : 'hidden'
            row.appendChild(caret)
            const icon = document.createElement('span')
            const isSftp = (n.session?.type||'').toUpperCase() === 'SFTP'
            icon.className = 'icon' + (isSftp ? ' sftp' : '')
            icon.innerHTML = n.type === 'folder'
              ? '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10 4l2 2h8a2 2 0 012 2v1H4V6a2 2 0 012-2h4zm12 6v8a2 2 0 01-2 2H6a2 2 0 01-2-2v-8h18z"/></svg>'
              : (isSftp
                ? '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16v2H4V4zm0 4h10v2H4V8zm0 4h16v2H4v-2zm0 4h10v2H4v-2z"/></svg>'
                : '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M3 5h18a2 2 0 012 2v10a2 2 0 01-2 2H3a2 2 0 01-2-2V7a2 2 0 012-2zm3 3v2h12V8H6zm0 4v2h8v-2H6z"/></svg>')
            row.appendChild(icon)
            const label = document.createElement('div')
            label.className = 'label'
            if (n.type === 'session') {
              const human = `${(n.session?.name||n.name||n.session?.host||'Session')} (${n.session?.username||'user'})`
              label.textContent = n.name || human
            } else {
              label.textContent = n.name || 'Folder'
            }
            row.appendChild(label)
            container.appendChild(row)

            row.onclick = (e) => {
              if (e.shiftKey && selectedId) {
                // Range selection with Shift+click
                multiSelectMode = true
                selectRange(selectedId, n.id)
                setSelectedId(n.id) // Set as primary selection
              } else if (e.ctrlKey || e.metaKey) {
                // Toggle selection with Ctrl+click
                if (isSelected(n.id)) {
                  removeFromSelection(n.id)
                  if (selectedId === n.id) {
                    selectedId = selectedIds.length > 0 ? selectedIds[selectedIds.length - 1] : null
                  }
                } else {
                  addToSelection(n.id)
                  setSelectedId(n.id) // Set as primary selection
                }
              } else {
                // Single selection
                clearSelection()
                setSelectedId(n.id)
                addToSelection(n.id) // Add to multi-selection array too
              }
              
              if (n.type === 'folder') { n.expanded = !n.expanded }
              renderTree()
            }
            row.ondblclick = async () => {
              if (n.type === 'folder') { return }
              if (n.type === 'session') {
                const s = n.session
                if ((s.type||'SSH').toUpperCase() === 'SFTP') {
                  // Create SFTP connection first, then tab
                  const rid = genId('sftp')
                  const cfg = Object.assign({}, s, { id: rid })
                  try {
                    await window.api.sftpConnect(cfg)
                    const remoteHost = (s.host || s.hostname || 'host')
                    const title = s.name ? `${s.name}` : `${remoteHost}`
                    const parentColor = findParentFolderColor(sessionTree, n.id)
                    createSftpTab(rid, title)
                    if (parentColor) {
                      const tabEl = tabs.get(rid)
                      if (tabEl) { tabEl.dataset.color = '1'; tabEl.style.setProperty('--tab-color', parentColor) }
                    }
                    activateTab(rid)
                    await initSftpSplitIfNeeded(rid)
                    await navigateRemote('/')
                  } catch (e) {
                    await showErrorModal('Connection error', String(e?.message||e))
                  }
                } else {
                  // Create SSH tab, attempt connect; on failure close tab and show styled error
                  const rid = genId('ssh')
                  const remoteHost = (s.host || s.hostname || 'host')
                  const title = s.name ? `${s.name}` : `${remoteHost}`
                  const parentColor = findParentFolderColor(sessionTree, n.id)
                  createTerminalFor(rid, title)
                  if (parentColor) {
                    const tabEl = tabs.get(rid)
                    if (tabEl) { tabEl.dataset.color = '1'; tabEl.style.setProperty('--tab-color', parentColor) }
                  }
                  const cfg = Object.assign({}, s, { id: rid })
                  try {
                    await window.api.sshConnect(cfg)
                    await window.api.sshOpenPtyId(rid)
                    try { await window.api.sftpConnect(cfg) } catch {}
                    const rec = terminals.get(rid)
                    try { rec.fit.fit() } catch {}
                    try { window.api.sshResizeId(rid, rec.term.cols, rec.term.rows) } catch {}
                    // Removed explicit "[Connected]" banner and extra CRLF to avoid redundant line on first connect
                    showSshView()
                    activateTab(rid)
                  } catch (e) {
                    closeTabById(rid)
                    await showErrorModal('Connection error', String(e?.message||e))
                  }
                }
              }
            }
            row.oncontextmenu = (e) => { 
              e.preventDefault(); 
              setSelectedId(n.id); 
              renderTree(); 
              openCtxMenu(e.clientX, e.clientY, n) 
            }

            // Drag and drop
            row.addEventListener('dragstart', (e) => {
              draggingId = n.id
              try { e.dataTransfer.setData('text/plain', n.id) } catch {}
              e.dataTransfer.effectAllowed = 'move'
            })
            row.addEventListener('dragend', () => { draggingId = null })
            row.addEventListener('mousemove', (e) => {
              const rect = row.getBoundingClientRect()
              const x = Math.round(e.clientX - rect.left)
              const y = Math.round(e.clientY - rect.top)
              row.style.setProperty('--mx', x + 'px')
              row.style.setProperty('--my', y + 'px')
            })
            row.addEventListener('dragover', (e) => {
              if (!draggingId || draggingId === n.id) return
              e.preventDefault(); e.stopPropagation()
              row.classList.add('drop-target')
            })
            row.addEventListener('dragleave', () => row.classList.remove('drop-target'))
            row.addEventListener('drop', async (e) => {
              e.preventDefault(); e.stopPropagation(); row.classList.remove('drop-target')
              const dragId = draggingId
              if (!dragId || dragId === n.id) return
              await moveNode(dragId, n)
              draggingId = null
            })

            if (n.type === 'folder' && n.expanded) {
              const children = document.createElement('div')
              children.className = 'children'
              container.appendChild(children)
              renderList(n.children || [], children, (n.color || effectiveColor || inheritedColor))
            }
          })
        }
        renderList(sessionTree, root, null)
      }

      function isDescendant(potentialParent, childId) {
        if (potentialParent.type !== 'folder') return false
        const stack = [...(potentialParent.children||[])]
        while (stack.length) {
          const x = stack.pop()
          if (!x) continue
          if (x.id === childId) return true
          if (x.type === 'folder') stack.push(...(x.children||[]))
        }
        return false
      }

      async function moveNode(sourceId, targetNode) {
        const srcInfo = findNodeById(sessionTree, sourceId, null)
        if (!srcInfo) return
        const srcNode = srcInfo.node

        // Determine drop target container and insertion index
        let container = null
        let insertIndex = null

        if (targetNode.type === 'folder') {
          // Prevent moving a folder into its descendant
          if (targetNode.id !== '__root__' && isDescendant(srcNode, targetNode.id)) return
          targetNode.expanded = true
          container = targetNode.id === '__root__' ? sessionTree : (targetNode.children || (targetNode.children = []))
          insertIndex = container.length // append to end of folder/root
        } else {
          // Dropping onto an item -> insert after the target item within its parent container
          const tgtInfo = findNodeById(sessionTree, targetNode.id, null)
          if (!tgtInfo) return
          container = tgtInfo.parent ? tgtInfo.parent.children : sessionTree
          insertIndex = (tgtInfo.index ?? 0) + 1
        }

        // If moving within the same container and the source was before the insert position,
        // removing the source will shift the target index by -1. Adjust for that.
        const movingWithinSameContainer = (srcInfo.parent ? srcInfo.parent.children : sessionTree) === container
        const originalSourceIndex = srcInfo.index

        // Remove from current location
        if (!srcInfo.parent) sessionTree.splice(srcInfo.index, 1)
        else srcInfo.parent.children.splice(srcInfo.index, 1)

        if (movingWithinSameContainer && originalSourceIndex < insertIndex) {
          insertIndex = Math.max(0, insertIndex - 1)
        }

        // Clamp insert index
        if (insertIndex < 0 || insertIndex > container.length) insertIndex = container.length

        // Insert at calculated position
        container.splice(insertIndex, 0, srcNode)

        await window.api.sessionsSaveTree(sessionTree)
        saveToHistory() // Save to history after drag and drop
      }

      function openCtxMenu(x, y, targetNode=null) {
        const menu = document.getElementById('ctx')
        menu.innerHTML = ''
        function add(label, handler) {
          const it = document.createElement('div');
          it.className='ctx-item';
          it.textContent=label;
          it.onmousedown=(e)=>{ e.preventDefault(); e.stopPropagation(); hideCtx(); handler() };
          menu.appendChild(it)
        }
        const isFolder = targetNode && targetNode.type==='folder'
        const isSession = targetNode && targetNode.type==='session'
        
        // Only show "New Folder" if not clicking on a session
        if (!isSession) {
          add('New Folder', async () => {
            const res = await showFolderModal('New Folder', 'New Folder', DEFAULT_FOLDER_COLOR, 'Create')
            if (!res) return
            const node = { id: genId('fld'), type:'folder', name: res.name, expanded:true, children:[] }
            if (res.color) node.color = res.color
            if (!targetNode || targetNode.type!=='folder') sessionTree.push(node)
            else {
              targetNode.children.push(node)
              // Auto-expand folder when creating folder inside it
              if (!targetNode.expanded) {
                targetNode.expanded = true
              }
            }
            await window.api.sessionsSaveTree(sessionTree)
            saveToHistory() // Save to history after creation
            renderTree() // Update tree display
          })
        }
        
        // Only show "New Session" if not clicking on a session
        if (!isSession) {
          add('New Session', async () => {
            const res = await window.api.openSessionWindow('SSH')
            const s = res && res.session
            if (!s) return
            const node = { id: genId('sess'), type:'session', name: `${s.name||s.host} (${s.username})`, session: s }
            if (!targetNode || targetNode.type!=='folder') sessionTree.push(node)
            else {
              targetNode.children.push(node)
              // Auto-expand folder when creating session inside it
              if (!targetNode.expanded) {
                targetNode.expanded = true
              }
            }
            await window.api.sessionsSaveTree(sessionTree)
            saveToHistory() // Save to history after creation
            renderTree() // Update tree display
          })
        }
        
        // Only show "Edit" if clicking on a node (not empty area)
        if (targetNode) {
          add('Edit…', async () => {
            if (!targetNode) return
            if (targetNode.type==='session') {
              const present = targetNode.session || {}
              const res = await window.api.openSessionWindowPreset((present.type||'SSH'), present)
              const s = res && res.session
              if (!s) return
              targetNode.session = s
              targetNode.name = `${s.name||s.host} (${s.username})`
            } else if (targetNode.type==='folder') {
              const res = await showFolderModal('Edit Folder', targetNode.name || 'Folder', (typeof targetNode.color==='string' && targetNode.color) ? targetNode.color : DEFAULT_FOLDER_COLOR, 'Save')
              if (!res) return
              targetNode.name = res.name || targetNode.name
              if (res.color) targetNode.color = res.color
            }
            await window.api.sessionsSaveTree(sessionTree)
            saveToHistory() // Save to history after edit
            renderTree() // Update tree display
          })
        }
        if (targetNode && (targetNode.type === 'session' || targetNode.type === 'folder')) {
          add('Copy', () => {
            if (selectedIds.length > 0) {
              copyMultipleSessions()
            } else {
              copySession(targetNode.id)
            }
          })
          add('Cut', () => {
            if (selectedIds.length > 0) {
              cutMultipleSessions()
            } else {
              cutSession(targetNode.id)
            }
          })
        }
        if (copiedSession) {
          add('Paste', async () => {
            await pasteSession(targetNode ? targetNode.id : null)
          })
        }
        if (historyIndex > 0) {
          add('Undo', async () => {
            await undo()
          })
        }
        if (historyIndex < history.length - 1) {
          add('Redo', async () => {
            await redo()
          })
        }
        
        // Only show "Create Tunnel" if clicking on a session (not folder or empty area)
        if (targetNode && targetNode.type === 'session') {
          add('Create Tunnel…', async () => {
            // Smart tunnel creation - find the best session to use
            let targetSession = null
            
            // Priority 1: If we have a selected session, use it
            if (selectedId) {
              const info = findNodeById(sessionTree, selectedId, null)
              if (info && info.node.type === 'session') {
                targetSession = info.node
              }
            }
            
            // Priority 2: If we have selected items, find first session among them
            if (!targetSession && selectedIds.length > 0) {
              const firstSelectedSession = selectedIds.find(id => {
                const info = findNodeById(sessionTree, id, null)
                return info && info.node.type === 'session'
              })
              if (firstSelectedSession) {
                const info = findNodeById(sessionTree, firstSelectedSession, null)
                targetSession = info.node
              }
            }
            
            // Priority 3: If we clicked on a session, use it
            if (!targetSession && targetNode && targetNode.type === 'session') {
              targetSession = targetNode
            }
            
            // Priority 4: If we clicked on a folder, find first session in it
            if (!targetSession && targetNode && targetNode.type === 'folder') {
              targetSession = findFirstSessionInFolder(targetNode)
            }
            
            // Priority 5: Find any session in the tree
            if (!targetSession) {
              targetSession = findFirstSessionInTree()
            }
            
            if (targetSession) {
              await createTunnelForSession(targetSession)
            } else {
              await showConfirmModal('No Sessions', 'No sessions found. Create a session first.', 'OK', '')
            }
          })
        }
        if ((selectedIds.length > 0 || selectedId) && targetNode) {
          add('Delete', async () => {
            if (selectedIds.length > 1 || (selectedIds.length === 1 && selectedId && selectedIds.includes(selectedId))) {
              await deleteMultipleSessions()
            } else if (selectedId) {
              const info = findNodeById(sessionTree, selectedId, null)
              if (info && (info.node.type === 'session' || info.node.type === 'folder')) {
                // Clear copied session if it's being deleted
                clearCopiedSession(selectedId)
                
                // Remove from tree
                if (info.parent) {
                  info.parent.children.splice(info.index, 1)
                } else {
                  sessionTree.splice(info.index, 1)
                }
                
                // Save changes
                await window.api.sessionsSaveTree(sessionTree)
                setSelectedId(null)
                renderTree()
              }
            }
          })
        }
        menu.style.left = x + 'px'; menu.style.top = y + 'px'; menu.style.display = 'block'
        setTimeout(() => {
          const onDoc = (e) => {
            if (!menu.contains(e.target)) { hideCtx(); document.removeEventListener('mousedown', onDoc) }
          }
          document.addEventListener('mousedown', onDoc)
        }, 0)
      }
      function hideCtx() { const menu = document.getElementById('ctx'); menu.style.display='none' }
      function openTabCtxMenu(x, y, tabId) {
        const menu = document.getElementById('ctx')
        menu.innerHTML = ''
        function add(label, handler) {
          const it = document.createElement('div');
          it.className='ctx-item';
          it.textContent=label;
          it.onmousedown=(e)=>{ e.preventDefault(); e.stopPropagation(); hideCtx(); handler() };
          menu.appendChild(it)
        }
        add('Rename…', async () => {
          const tabEl = tabs.get(tabId)
          if (!tabEl) return
          const titleEl = tabEl.querySelector('.title')
          const current = titleEl ? (titleEl.textContent || '') : (tabEl.title || '')
          const next = await showInputModal('Rename Tab', 'New name', current)
          if (!next) return
          if (titleEl) titleEl.textContent = next
          tabEl.title = next
        })
        add('Color…', async () => {
          const tabEl = tabs.get(tabId)
          if (!tabEl) return
          const current = tabEl.style.getPropertyValue('--tab-color') || '#3a4160'
          const picked = await showColorModal('Tab Color', current)
          if (!picked) return
          tabEl.dataset.color = '1'
          tabEl.style.setProperty('--tab-color', picked)
        })
        add('Clear Color', () => {
          const tabEl = tabs.get(tabId)
          if (!tabEl) return
          delete tabEl.dataset.color
          tabEl.style.removeProperty('--tab-color')
        })
        add('Close', async () => {
          const closeBtn = tabs.get(tabId)?.querySelector('.close')
          if (closeBtn) closeBtn.click()
        })
        menu.style.left = x + 'px'; menu.style.top = y + 'px'; menu.style.display = 'block'
        setTimeout(() => {
          const onDoc = (e) => { if (!menu.contains(e.target)) { hideCtx(); document.removeEventListener('mousedown', onDoc) } }
          document.addEventListener('mousedown', onDoc)
        }, 0)
      }
      document.getElementById('left').oncontextmenu = (e) => { if (e.target && e.target.closest('.item')) return; e.preventDefault(); openCtxMenu(e.clientX, e.clientY, null) }
      document.addEventListener('keydown', async (e) => {
        // Save selection state at the very beginning of keydown event
        const currentSelectedId = selectedId
        const currentSelectedIds = [...selectedIds]
        const currentMultiSelectMode = multiSelectMode
        // Copy selection on Ctrl+Shift+C when a terminal is active
        if ((e.key === 'c' || e.key === 'C') && e.ctrlKey && e.shiftKey) {
          const active = currentId != null ? terminals.get(currentId) : null
          const term = active && active.term
          if (term && typeof term.hasSelection === 'function' && term.hasSelection()) {
            try { window.api.copyText(term.getSelection()) } catch {}
            e.preventDefault()
            e.stopPropagation()
            return
          }
        }
        // Zoom controls for active terminal:
        // Ctrl+Shift+= (which is '+') -> zoom in
        // Ctrl+- -> zoom out
        // Ctrl+= -> reset to initial font size
        if (e.ctrlKey) {
          // If event originated inside xterm, let xterm handler manage it to avoid double handling
          try {
            const t = e.target
            if (t && typeof t.closest === 'function' && t.closest('.xterm')) {
              // Do not handle here
            } else {
              const isPlus = (e.key === '+' || (e.key === '=' && e.shiftKey) || e.code === 'NumpadAdd')
              const isMinus = (e.key === '-' || e.code === 'NumpadSubtract')
              const isReset = (e.key === '=' && !e.shiftKey)
              if (isPlus || isMinus || isReset) {
                // Guard to ensure one action per physical press
                if ((isPlus && zoomGuard.in) || (isMinus && zoomGuard.out) || (isReset && zoomGuard.reset)) {
                  e.preventDefault(); e.stopPropagation(); return
                }
                const rec = currentId != null ? terminals.get(currentId) : null
                const term = rec && rec.term
                if (term) {
                  try {
                    const current = (typeof rec.currFontSize === 'number') ? rec.currFontSize : (Number(term.options && term.options.fontSize) || 15)
                    const base = (typeof rec.baseFontSize === 'number') ? rec.baseFontSize : (Number(term.options && term.options.fontSize) || 15)
                    let next = current
                    if (isPlus) next = Math.min(ZOOM_MAX, current + ZOOM_STEP)
                    else if (isMinus) next = Math.max(ZOOM_MIN, current - ZOOM_STEP)
                    else if (isReset) next = base
                    if (next !== current) {
                      try { term.options.fontSize = next } catch {}
                      rec.currFontSize = next
                      try { resize() } catch {}
                    }
                  } catch {}
                  if (isPlus) zoomGuard.in = true
                  if (isMinus) zoomGuard.out = true
                  if (isReset) zoomGuard.reset = true
                  e.preventDefault()
                  e.stopPropagation()
                  return
                }
              }
            }
          } catch {}
        }
        if (e.key === 'Delete' && selectedId) {
          const ok = await showConfirmModal('Delete', 'Delete selected item?', 'Delete', 'Cancel')
          if (!ok) return
          clearCopiedSession(selectedId) // Clear copied session if it's being deleted
          removeNodeById(selectedId)
          selectedId = null
          await window.api.sessionsSaveTree(sessionTree)
          renderTree()
        }
        if (e.key === 'F2' && selectedId) {
          const info = findNodeById(sessionTree, selectedId, null)
          if (!info) return
          const isSession = info.node.type === 'session'
          const currentName = isSession ? (info.node.name || info.node.session?.name || '') : (info.node.name || '')
          const newName = await showInputModal('Rename', 'New name', currentName)
          if (!newName) return
          if (isSession) {
            info.node.name = newName
          } else {
            info.node.name = newName
          }
          await window.api.sessionsSaveTree(sessionTree)
          saveToHistory() // Save to history after rename
          renderTree()
        }
        // Copy session or folder with Ctrl+C
        if (e.ctrlKey && e.key === 'c' && (selectedId || selectedIds.length > 0)) {
          if (selectedIds.length > 1 || (selectedIds.length === 1 && selectedId && selectedIds.includes(selectedId))) {
            copyMultipleSessions()
          } else if (selectedId) {
            const info = findNodeById(sessionTree, selectedId, null)
            if (info && (info.node.type === 'session' || info.node.type === 'folder')) {
              copySession(selectedId)
            }
          }
          e.preventDefault()
          e.stopPropagation()
        }
        // Cut session or folder with Ctrl+X
        if (e.ctrlKey && e.key === 'x' && (selectedId || selectedIds.length > 0)) {
          if (selectedIds.length > 1 || (selectedIds.length === 1 && selectedId && selectedIds.includes(selectedId))) {
            cutMultipleSessions()
          } else if (selectedId) {
            const info = findNodeById(sessionTree, selectedId, null)
            if (info && (info.node.type === 'session' || info.node.type === 'folder')) {
              cutSession(selectedId)
            }
          }
          e.preventDefault()
          e.stopPropagation()
        }
        // Paste session or folder with Ctrl+V
        if (e.ctrlKey && e.key === 'v' && copiedSession) {
          // If we have a selected item, paste into it, otherwise use the original context
          const targetId = selectedId || copiedFromContext
          await pasteSession(targetId)
          e.preventDefault()
          e.stopPropagation()
        }
        // Undo with Ctrl+Z
        if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
          await undo()
          e.preventDefault()
          e.stopPropagation()
        }
        // Redo with Ctrl+Y or Ctrl+Shift+Z
        if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
          await redo()
          e.preventDefault()
          e.stopPropagation()
        }
        // Delete selected sessions or folders with Delete key
        if (e.key === 'Delete' || e.keyCode === 46) {
          if (currentSelectedIds.length > 0) {
            // Multi-delete - temporarily restore selection
            selectedId = currentSelectedId
            selectedIds = [...currentSelectedIds]
            multiSelectMode = currentMultiSelectMode
            await deleteMultipleSessions()
            e.preventDefault()
            e.stopPropagation()
          } else if (currentSelectedId) {
            // Single delete
            const info = findNodeById(sessionTree, currentSelectedId, null)
            if (info && (info.node.type === 'session' || info.node.type === 'folder')) {
              // Clear copied session if it's being deleted
              clearCopiedSession(currentSelectedId)
              
              // Remove from tree
              if (info.parent) {
                info.parent.children.splice(info.index, 1)
              } else {
                sessionTree.splice(info.index, 1)
              }
              
              // Save changes
              await window.api.sessionsSaveTree(sessionTree)
              saveToHistory() // Save to history after deletion
              setSelectedId(null)
              renderTree()
            }
            e.preventDefault()
            e.stopPropagation()
          }
        }
      })

      // Clear zoom guard on keyup to allow next press
      document.addEventListener('keyup', (e) => {
        try {
          if (e.key === 'Control') { zoomGuard.in = zoomGuard.out = zoomGuard.reset = false; return }
          if (e.code === 'NumpadAdd' || e.key === '+' || (e.key === '=' && e.shiftKey)) { zoomGuard.in = false }
          if (e.code === 'NumpadSubtract' || e.key === '-') { zoomGuard.out = false }
          if (e.key === '=' && !e.shiftKey) { zoomGuard.reset = false }
        } catch {}
      })

      // Modal for input (since prompt is disabled in secure Electron)
      function showInputModal(title, placeholder, initialValue='') {
        return new Promise((resolve) => {
          const overlay = document.createElement('div')
          overlay.className = 'modal-overlay'
          const modal = document.createElement('div')
          modal.className = 'modal'
          const header = document.createElement('div')
          header.className = 'modal-header'
          header.textContent = title
          const body = document.createElement('div')
          body.className = 'modal-body'
          const input = document.createElement('input')
          input.className = 'input'
          input.placeholder = placeholder || ''
          input.value = initialValue || ''
          body.appendChild(input)
          const actions = document.createElement('div')
          actions.className = 'modal-actions'
          const btnCancel = document.createElement('button')
          btnCancel.className = 'btn'
          btnCancel.textContent = 'Cancel'
          const btnOk = document.createElement('button')
          btnOk.className = 'btn primary'
          btnOk.textContent = 'Create'
          actions.appendChild(btnCancel)
          actions.appendChild(btnOk)
          modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions)
          overlay.appendChild(modal)
          document.body.appendChild(overlay)

          const close = (val) => { try { document.body.removeChild(overlay) } catch {}; resolve(val) }
          btnCancel.onclick = () => close(null)
          btnOk.onclick = () => close((input.value||'').trim())
          overlay.addEventListener('keydown', (e) => { if (e.key==='Escape') close(null) })
          input.addEventListener('keydown', (e) => { if (e.key==='Enter') btnOk.click() })
          setTimeout(() => input.focus(), 0)
        })
      }

      function showConfirmModal(title, message, okLabel='OK', cancelLabel='Cancel') {
        return new Promise((resolve) => {
          const overlay = document.createElement('div')
          overlay.className = 'modal-overlay'
          const modal = document.createElement('div')
          modal.className = 'modal'
          const header = document.createElement('div')
          header.className = 'modal-header'
          header.textContent = title
          const body = document.createElement('div')
          body.className = 'modal-body'
          const text = document.createElement('div')
          text.textContent = message
          body.appendChild(text)
          const actions = document.createElement('div')
          actions.className = 'modal-actions'
          const btnOk = document.createElement('button')
          btnOk.className = 'btn primary'
          btnOk.textContent = okLabel
          if (cancelLabel) {
            const btnCancel = document.createElement('button')
            btnCancel.className = 'btn'
            btnCancel.textContent = cancelLabel
            btnCancel.onclick = () => close(false)
            actions.appendChild(btnCancel)
          }
          actions.appendChild(btnOk)
          modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions)
          overlay.appendChild(modal)
          document.body.appendChild(overlay)

          const close = (val) => { try { document.body.removeChild(overlay) } catch {}; resolve(val) }
          btnOk.onclick = () => close(true)
          overlay.addEventListener('keydown', (e) => { if (e.key==='Escape') close(cancelLabel ? false : true) })
          setTimeout(() => btnOk.focus(), 0)
        })
      }

      function showColorModal(title, initialValue='#3a4160') {
        return new Promise((resolve) => {
          const overlay = document.createElement('div')
          overlay.className = 'modal-overlay'
          const modal = document.createElement('div')
          modal.className = 'modal'
          const header = document.createElement('div')
          header.className = 'modal-header'
          header.textContent = title || 'Pick a color'
          const body = document.createElement('div')
          body.className = 'modal-body'
          const pickerWrap = document.createElement('div')
          pickerWrap.style.display = 'flex'
          pickerWrap.style.alignItems = 'center'
          pickerWrap.style.gap = '10px'
          const input = document.createElement('input')
          input.type = 'color'
          input.value = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(initialValue||'') ? initialValue : '#3a4160'
          input.style.width = '44px'
          input.style.height = '32px'
          const hex = document.createElement('input')
          hex.className = 'input'
          hex.style.flex = '1'
          hex.placeholder = '#rrggbb'
          hex.value = input.value
          input.addEventListener('input', () => { hex.value = input.value })
          hex.addEventListener('input', () => {
            const v = hex.value.trim()
            if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)) input.value = v
          })
          pickerWrap.appendChild(input)
          pickerWrap.appendChild(hex)
          body.appendChild(pickerWrap)
          const actions = document.createElement('div')
          actions.className = 'modal-actions'
          const btnCancel = document.createElement('button')
          btnCancel.className = 'btn'
          btnCancel.textContent = 'Cancel'
          const btnOk = document.createElement('button')
          btnOk.className = 'btn primary'
          btnOk.textContent = 'Apply'
          actions.appendChild(btnCancel)
          actions.appendChild(btnOk)
          modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions)
          overlay.appendChild(modal)
          document.body.appendChild(overlay)
          const close = (val) => { try { document.body.removeChild(overlay) } catch {}; resolve(val) }
          btnCancel.onclick = () => close(null)
          btnOk.onclick = () => close(input.value)
          overlay.addEventListener('keydown', (e) => { if (e.key==='Escape') close(null) })
          setTimeout(() => input.focus(), 0)
        })
      }

      function showFolderModal(title, initialName='New Folder', initialColor=DEFAULT_FOLDER_COLOR, okLabel='Create') {
        return new Promise((resolve) => {
          const overlay = document.createElement('div')
          overlay.className = 'modal-overlay'
          const modal = document.createElement('div')
          modal.className = 'modal'
          const header = document.createElement('div')
          header.className = 'modal-header'
          header.textContent = title || 'Folder'
          const body = document.createElement('div')
          body.className = 'modal-body'

          const nameLabel = document.createElement('label')
          nameLabel.textContent = 'Name'
          const nameInput = document.createElement('input')
          nameInput.className = 'input'
          nameInput.placeholder = 'Folder name'
          nameInput.value = initialName || 'New Folder'
          body.appendChild(nameLabel)
          body.appendChild(nameInput)

          const colorLabel = document.createElement('label')
          colorLabel.textContent = 'Color'
          const colorRow = document.createElement('div')
          colorRow.style.display = 'flex'
          colorRow.style.alignItems = 'center'
          colorRow.style.gap = '10px'
          const colorPicker = document.createElement('input')
          colorPicker.type = 'color'
          colorPicker.value = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(initialColor||'') ? initialColor : '#7a5cf0'
          colorPicker.style.width = '44px'
          colorPicker.style.height = '32px'
          const colorHex = document.createElement('input')
          colorHex.className = 'input'
          colorHex.style.flex = '1'
          colorHex.placeholder = '#rrggbb'
          colorHex.value = colorPicker.value
          colorPicker.addEventListener('input', () => { colorHex.value = colorPicker.value })
          colorHex.addEventListener('input', () => {
            const v = (colorHex.value||'').trim()
            if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)) colorPicker.value = v
          })
          colorRow.appendChild(colorPicker)
          colorRow.appendChild(colorHex)
          body.appendChild(colorLabel)
          body.appendChild(colorRow)

          const actions = document.createElement('div')
          actions.className = 'modal-actions'
          const btnCancel = document.createElement('button')
          btnCancel.className = 'btn'
          btnCancel.textContent = 'Cancel'
          const btnOk = document.createElement('button')
          btnOk.className = 'btn primary'
          btnOk.textContent = okLabel || 'Create'
          actions.appendChild(btnCancel)
          actions.appendChild(btnOk)
          modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions)
          overlay.appendChild(modal)
          document.body.appendChild(overlay)
          const close = (val) => { try { document.body.removeChild(overlay) } catch {}; resolve(val) }
          btnCancel.onclick = () => close(null)
          btnOk.onclick = () => {
            const name = (nameInput.value||'').trim()
            if (!name) { nameInput.focus(); return }
            const color = (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(colorHex.value||'')) ? colorHex.value : colorPicker.value
            close({ name, color })
          }
          overlay.addEventListener('keydown', (e) => { if (e.key==='Escape') close(null); if (e.key==='Enter') btnOk.click() })
          setTimeout(() => nameInput.focus(), 0)
        })
      }

      function showErrorModal(title, message) {
        return new Promise((resolve) => {
          const overlay = document.createElement('div')
          overlay.className = 'modal-overlay'
          const modal = document.createElement('div')
          modal.className = 'modal'
          const header = document.createElement('div')
          header.className = 'modal-header'
          header.textContent = title
          const body = document.createElement('div')
          body.className = 'modal-body'
          const text = document.createElement('div')
          text.style.whiteSpace = 'pre-wrap'
          text.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
          text.textContent = message
          body.appendChild(text)
          const actions = document.createElement('div')
          actions.className = 'modal-actions'
          const btnOk = document.createElement('button')
          btnOk.className = 'btn primary'
          btnOk.textContent = 'OK'
          actions.appendChild(btnOk)
          modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions)
          overlay.appendChild(modal)
          document.body.appendChild(overlay)
          const close = () => { try { document.body.removeChild(overlay) } catch {}; resolve() }
          btnOk.onclick = close
          overlay.addEventListener('keydown', (e) => { if (e.key==='Escape') close() })
          setTimeout(() => btnOk.focus(), 0)
        })
      }

      // Load tree
      let renderPending = null
      async function refreshSessions() {
        const res = await window.api.sessionsLoad()
        sessionTree = Array.isArray(res?.tree) ? res.tree : []
        
        // Initialize history with current state
        history = [JSON.parse(JSON.stringify(sessionTree))]
        historyIndex = 0
        
        if (renderPending) cancelAnimationFrame(renderPending)
        renderPending = requestAnimationFrame(() => { renderPending = null; renderTree() })
      }
      refreshSessions()
      // Disable automatic session updates to prevent history reset
      // window.api.onSessionsUpdated(() => refreshSessions())
      
      // Click outside to clear selection
      document.addEventListener('click', (e) => {
        // Check if click is on a tree item or outside the tree
        const isTreeItem = e.target.closest('.item')
        const treeContainer = document.getElementById('tree')
        const isInsideTree = treeContainer && treeContainer.contains(e.target)
        
        if (!isTreeItem && !isInsideTree) {
          clearSelection()
          renderTree()
        }
      })
      


      // ===== SFTP UI =====
      // Split refs
      const sftpLocalListEl = document.getElementById('sftp-local-list')
      const sftpLocalPathEl = document.getElementById('sftp-local-path')
      const sftpLocalUpBtn = document.getElementById('sftp-local-up')
      const sftpLocalRefreshBtn = document.getElementById('sftp-local-refresh')

      const sftpRemoteListEl = document.getElementById('sftp-remote-list')
      const sftpRemotePathEl = document.getElementById('sftp-remote-path')
      const sftpRemoteUpBtn = document.getElementById('sftp-remote-up')
      const sftpRemoteRefreshBtn = document.getElementById('sftp-remote-refresh')
      // no explicit remote connect button anymore

      async function renderListInto(el, basePath, items, onEnterDir) {
        el.innerHTML = ''
        const rows = document.createDocumentFragment()
        {
          const isLocal = el && el.id === 'sftp-local-list'
          let shouldShowUp = false
          let upTarget = null
          if (isLocal) {
            try {
              const up = await window.api.pathDirname(basePath)
              if (up && up !== basePath) { shouldShowUp = true; upTarget = up }
            } catch {}
          } else {
            shouldShowUp = Boolean(basePath && basePath !== '/')
            upTarget = dirname(basePath)
          }
          if (shouldShowUp) {
            const upRow = document.createElement('div')
            upRow.className = 'sftp-row'
            upRow.innerHTML = '<span class="icon"><svg viewBox="0 0 24 24"><path d="M12 5l6 6h-4v6h-4v-6H6l6-6z"/></svg></span><div class="sftp-name">..</div><div class="sftp-type"></div>'
            upRow.ondblclick = () => onEnterDir(upTarget)
            rows.appendChild(upRow)
          }
        }
        for (const it of items || []) {
          const row = document.createElement('div')
          row.className = 'sftp-row'
          const isDir = (it.type === 'd')
          const rawName = String(it.name || it.displayName || it.pathName || '')
          const displayName = rawName
          const pathName = rawName
          const folderIcon = '<span class="icon"><svg viewBox="0 0 24 24"><path d="M10 4l2 2h8a2 2 0 012 2v1H4V6a2 2 0 012-2h4zm12 6v8a2 2 0 01-2 2H6a2 2 0 01-2-2v-8h18z"/></svg></span>'
          const fileIcon = '<span class="icon"><svg viewBox="0 0 24 24"><path d="M4 3h16a2 2 0 012 2v14a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2zm3 4v2h10V7H7zm0 4v2h6v-2H7z"/></svg></span>'
          row.innerHTML = `${isDir ? folderIcon : fileIcon}<div class="sftp-name" title="${displayName}">${displayName}</div><div class="sftp-type">${isDir?'dir':'file'}</div>`
          // Navigate by double click
          row.ondblclick = async () => {
            if (!isDir) return
            if (el && el.id === 'sftp-local-list') {
              const next = await window.api.pathJoin(basePath, pathName)
              onEnterDir(next)
            } else {
              onEnterDir(joinPath(basePath, pathName))
            }
          }
          // Context menu
          row.oncontextmenu = (e) => { e.preventDefault(); openSftpCtxMenu(e.clientX, e.clientY, { basePath, name: displayName, pathName, isDir, ownerEl: el }) }
          // Drag support
          row.draggable = true
          row.addEventListener('dragstart', (e) => {
            e.dataTransfer.effectAllowed = 'copyMove'
            const payload = JSON.stringify({ name: displayName, pathName, basePath, isDir, areaId: el.id })
            try { e.dataTransfer.setData('application/json', payload) } catch {}
          })
          rows.appendChild(row)
        }
        el.appendChild(rows)
      }

      function normalizeSftpItems(basePath, rawItems) { return rawItems }

      async function openSftpCtxMenu(x, y, info) {
        const menu = document.getElementById('ctx')
        menu.innerHTML = ''
        function add(label, handler) {
          const it = document.createElement('div'); it.className='ctx-item'; it.textContent=label; it.onmousedown=(e)=>{ e.preventDefault(); e.stopPropagation(); hideCtx(); handler() }; menu.appendChild(it)
        }
        const { basePath, name, pathName, isDir, ownerEl } = info
        const isRemote = ownerEl && ownerEl.id === 'sftp-remote-list'
        const fullPath = isRemote
          ? joinPath(basePath, (pathName || name))
          : await window.api.pathJoin(basePath, (pathName || name))
        
        add('Rename…', async () => {
          const newName = await showInputModal('Rename', 'New name', name)
          if (!newName) return
          if (isRemote) {
            const id = currentId
            await window.api.sftpRename(id, fullPath, joinPath(basePath, newName))
            await navigateRemote(basePath)
          } else {
            await window.api.localRename(fullPath, await window.api.pathJoin(basePath, newName))
            await navigateLocal(basePath)
          }
        })
        add('Delete…', async () => {
          const ok = await showConfirmModal('Delete', `Delete ${name}?`, 'Delete', 'Cancel')
          if (!ok) return
          if (isRemote) {
            const id = currentId
            await window.api.sftpDelete(id, fullPath, isDir)
            await navigateRemote(basePath)
          } else {
            await window.api.localDelete(fullPath, isDir)
            await navigateLocal(basePath)
          }
        })
        add('New Folder…', async () => {
          const newName = await showInputModal('New Folder', 'Folder name', 'New Folder')
          if (!newName) return
          const targetDir = basePath
          if (isRemote) {
            const id = currentId
            await window.api.sftpMkdir(id, joinPath(targetDir, newName))
            await navigateRemote(targetDir)
          } else {
            await window.api.localMkdir(await window.api.pathJoin(targetDir, newName))
            await navigateLocal(targetDir)
          }
        })
        menu.style.left = x + 'px'; menu.style.top = y + 'px'; menu.style.display = 'block'
        setTimeout(() => { const onDoc = (e) => { if (!menu.contains(e.target)) { hideCtx(); document.removeEventListener('mousedown', onDoc) } }; document.addEventListener('mousedown', onDoc) }, 0)
      }

      ;['sftp-local-list','sftp-remote-list'].forEach((id) => {
        const el = document.getElementById(id)
        el.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy' })
        el.addEventListener('drop', async (e) => {
          e.preventDefault()
          let data = null
          try { data = JSON.parse(e.dataTransfer.getData('application/json')) } catch {}
          if (!data || !data.name || !data.basePath) return
          const srcFull = (data.areaId === 'sftp-remote-list')
            ? joinPath(data.basePath, (data.pathName || data.name))
            : await window.api.pathJoin(data.basePath, (data.pathName || data.name))
          const dstIsRemote = id === 'sftp-remote-list'
          const srcIsRemote = data.areaId === 'sftp-remote-list'
          const dstBase = dstIsRemote ? sftpRemotePathEl.value : sftpLocalPathEl.value
          const dstFull = dstIsRemote
            ? joinPath(dstBase, (data.pathName || data.name))
            : await window.api.pathJoin(dstBase, (data.pathName || data.name))
          try {
            if (srcIsRemote && !dstIsRemote) {
              await window.api.sftpDownload(currentId, srcFull, dstFull)
              await navigateLocal(dstBase)
            } else if (!srcIsRemote && dstIsRemote) {
              await window.api.sftpUpload(currentId, srcFull, dstFull)
              await navigateRemote(dstBase)
            } else {
              // same side drop: skip for now
            }
          } catch (e2) { alert('Transfer error: ' + (e2?.message||e2)) }
        })
      })

      function joinPath(a, b) {
        // Use main process to handle OS-specific separators for local paths only when called for local area
        // For remote SFTP we keep POSIX join in navigateRemote
        return (a && a.includes('\\')) ? null : ( (!a || a === '/') ? ('/' + (b||'').replace(/^\/+/, '')) : (a.replace(/\/+$/,'') + '/' + (b||'').replace(/^\/+/, '')) )
      }
      function dirname(p) {
        if (p && p.includes('\\')) return null
        if (!p || p === '/') return '/'
        const parts = p.replace(/\/+$/,'').split('/')
        parts.pop()
        const out = parts.join('/')
        return out ? (out.startsWith('/') ? out : '/' + out) : '/'
      }

      async function listRemote(p) {
        const list = await window.api.sftpListById(currentId, p)
        await renderListInto(sftpRemoteListEl, p, list, navigateRemote)
      }
      async function navigateRemote(p) {
        sftpRemotePathEl.value = p
        try { await listRemote(p) } catch (e) { showErrorModal('SFTP list error', String(e?.message||e)) }
      }
      async function listLocal(p) {
        const list = await window.api.localList(p)
        await renderListInto(sftpLocalListEl, p, list, navigateLocal)
      }
      async function navigateLocal(p) {
        sftpLocalPathEl.value = p
        try { await listLocal(p) } catch (e) { showErrorModal('Local list error', String(e?.message||e)) }
      }

      async function initSftpSplitIfNeeded(id) {
        // Initialize local path to home directory once
        if (!sftpLocalPathEl.dataset.ready) {
          const home = await window.api.getHome().catch(() => '/')
          await navigateLocal(home || '/')
          sftpLocalPathEl.dataset.ready = '1'
        }
        // Remote path default root
        await navigateRemote('/')
      }

      sftpRemoteRefreshBtn.onclick = () => navigateRemote(sftpRemotePathEl.value)
      sftpRemoteUpBtn.onclick = () => navigateRemote(dirname(sftpRemotePathEl.value))
      sftpRemotePathEl.addEventListener('keydown', (e) => { if (e.key==='Enter') navigateRemote(sftpRemotePathEl.value) })
      // connection is established on double-click of SFTP session in the tree

      sftpLocalRefreshBtn.onclick = () => navigateLocal(sftpLocalPathEl.value)
      sftpLocalUpBtn.onclick = async () => {
        const p = sftpLocalPathEl.value
        const up = await window.api.pathDirname(p)
        await navigateLocal(up)
      }
      sftpLocalPathEl.addEventListener('keydown', async (e) => { if (e.key==='Enter') { await navigateLocal(sftpLocalPathEl.value) } })

      // ===== Tunneling UI =====
      const tunListEl = document.getElementById('tun-list')
      const tunCreateBtn = document.getElementById('tun-create')
      let tunnels = [] // persisted list: { id, sessionId, name, localHost, localPort, remoteHost, remotePort, active }
      
      // Find first session in folder (recursive)
      function findFirstSessionInFolder(folder) {
        if (!folder.children) return null
        for (const child of folder.children) {
          if (child.type === 'session') {
            return child
          } else if (child.type === 'folder') {
            const found = findFirstSessionInFolder(child)
            if (found) return found
          }
        }
        return null
      }
      
      // Find first session in entire tree
      function findFirstSessionInTree() {
        for (const item of sessionTree) {
          if (item.type === 'session') {
            return item
          } else if (item.type === 'folder') {
            const found = findFirstSessionInFolder(item)
            if (found) return found
          }
        }
        return null
      }
      
      // Create tunnel for specific session
      async function createTunnelForSession(sessNode) {
        // Modal wizard
        const overlay = document.createElement('div'); overlay.className='modal-overlay'
        const modal = document.createElement('div'); modal.className='modal'
        const header = document.createElement('div'); header.className='modal-header'; header.textContent='Create Tunnel'
        const body = document.createElement('div'); body.className='modal-body'
        const step1 = document.createElement('div'); step1.style.display='flex'; step1.style.gap='8px'; step1.style.alignItems='center'
        step1.innerHTML = '<span>Local port</span>'
        const inLocal = document.createElement('input'); inLocal.className='input'; inLocal.placeholder='8080'; inLocal.value='8080'
        step1.appendChild(inLocal)
        const step2 = document.createElement('div'); step2.style.display='none'; step2.style.gap='8px'; step2.style.alignItems='center'
        step2.innerHTML = '<span>Remote port</span>'
        const inRemote = document.createElement('input'); inRemote.className='input'; inRemote.placeholder='80'; inRemote.value='80'
        step2.appendChild(inRemote)
        const step3 = document.createElement('div'); step3.style.display='none'; step3.style.gap='8px'; step3.style.alignItems='center'
        step3.innerHTML = '<span>Name (optional)</span>'
        const inName = document.createElement('input'); inName.className='input'; inName.placeholder='My tunnel'
        step3.appendChild(inName)
        body.appendChild(step1); body.appendChild(step2); body.appendChild(step3)
        const actions = document.createElement('div'); actions.className='modal-actions'
        const btnNext = document.createElement('button'); btnNext.className='btn primary'; btnNext.textContent='Next'
        const btnCancel = document.createElement('button'); btnCancel.className='btn'; btnCancel.textContent='Cancel'
        const btnCreate = document.createElement('button'); btnCreate.className='btn primary'; btnCreate.textContent='Create'; btnCreate.style.display='none'
        actions.appendChild(btnNext); actions.appendChild(btnCancel); actions.appendChild(btnCreate)
        modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions)
        overlay.appendChild(modal); document.body.appendChild(overlay)
        const close = () => { document.body.removeChild(overlay) }
        btnCancel.onclick = close
        let step = 1
        btnNext.onclick = () => {
          if (step === 1) {
            step1.style.display='none'; step2.style.display='flex'; step++
            inRemote.focus()
          } else if (step === 2) {
            step2.style.display='none'; step3.style.display='flex'; step++
            btnNext.style.display='none'; btnCreate.style.display='inline-block'
            inName.focus()
          }
        }
        btnCreate.onclick = async () => {
          const localPort = Number(inLocal.value || '0')
          const remotePort = Number(inRemote.value || '0')
          if (!localPort || !remotePort) { alert('Ports are required'); return }
          const name = (inName.value || '').trim()
          const remoteHost = (sessNode.session && (sessNode.session.host || sessNode.session.hostname)) || '127.0.0.1'
          // Add tunnel inactive by default
          const entry = { id: genId('tun'), sessionId: sessNode.id, sessionCfg: sessNode.session, name, localHost:'127.0.0.1', localPort, remoteHost, remotePort, active:false }
          tunnels.push(entry)
          await window.api.tunnelsSave(tunnels)
          renderTunnels()
          close()
        }
        overlay.addEventListener('keydown', (e) => { if (e.key==='Escape') close() })
        setTimeout(() => inLocal.focus(), 0)
      }

      function renderTunnels() {
        tunListEl.innerHTML = ''
        for (let i=0;i<tunnels.length;i++) {
          const t = tunnels[i]
          const row = document.createElement('div')
          row.className = 'tun-row'
          const colA = document.createElement('div'); colA.className='tun-col small'; colA.textContent = t.name || '(no name)'
          const colB = document.createElement('div'); colB.className='tun-col'; colB.textContent = `${t.remoteHost||'127.0.0.1'}:${t.remotePort} -> ${t.localHost||'127.0.0.1'}:${t.localPort}`
          if (t.active) { const dot = document.createElement('span'); dot.className='tun-dot active'; colB.appendChild(dot) }
          const colC = document.createElement('div'); colC.className='tun-col small'
          const startBtn = document.createElement('button'); startBtn.className='icon-btn'; startBtn.title='Start'
          startBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M8 5v14l11-7z"/></svg>'
          const stopBtn = document.createElement('button'); stopBtn.className='icon-btn'; stopBtn.title='Stop'
          stopBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M6 6h12v12H6z"/></svg>'
          const editBtn = document.createElement('button'); editBtn.className='icon-btn'; editBtn.title='Edit'
          editBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a1.003 1.003 0 0 0 0-1.42l-2.34-2.34a1.003 1.003 0 0 0-1.42 0l-1.83 1.83 3.75 3.75 1.84-1.82z"/></svg>'
          const delBtn = document.createElement('button'); delBtn.className='icon-btn'; delBtn.title='Delete'
          delBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M6 7h12l-1 12H7L6 7zm3-3h6l1 2H8l1-2z"/></svg>'
          if (t.active) startBtn.style.opacity = '0.4'; else stopBtn.style.opacity = '0.4'
          startBtn.onclick = async () => {
            if (t.active) return
            try {
              // Ensure SSH connection exists for this tunnel
              if (!t.connId) {
                t.connId = genId('tunconn')
                const cfg = Object.assign({}, t.sessionCfg || {}, { id: t.connId })
                await window.api.sshConnect(cfg)
              }
              await window.api.tunnelStart(t.connId, t.localHost||'127.0.0.1', t.localPort, (t.sessionCfg?.host || t.remoteHost || '127.0.0.1'), t.remotePort)
              t.active = true
              await window.api.tunnelsSave(tunnels)
              renderTunnels()
            } catch (e) { alert('Start error: ' + (e?.message||e)) }
          }
          stopBtn.onclick = async () => {
            if (!t.active) return
            try {
              await window.api.tunnelStop(t.connId || t.sessionId, t.localPort)
              try { if (t.connId) await window.api.sshDisconnect(t.connId) } catch {}
              t.active = false
              t.connId = undefined
              await window.api.tunnelsSave(tunnels)
              renderTunnels()
            } catch (e) { alert('Stop error: ' + (e?.message||e)) }
          }
          editBtn.onclick = async () => {
            try {
              const res = await window.api.openTunnelWindow(Object.assign({}, t))
              const updated = res && res.tunnel
              if (!updated) return
              updated.active = t.active
              updated.connId = t.connId
              if (!updated.id) updated.id = t.id
              tunnels[i] = updated
              await window.api.tunnelsSave(tunnels)
              renderTunnels()
            } catch (e) { alert('Edit error: ' + (e?.message||e)) }
          }
          delBtn.onclick = async () => {
            const ok = await showConfirmModal('Delete tunnel', `Delete ${t.name||''}?`, 'Delete', 'Cancel')
            if (!ok) return
            try {
              if (t.active) {
                await window.api.tunnelStop(t.connId || t.sessionId, t.localPort)
                try { if (t.connId) await window.api.sshDisconnect(t.connId) } catch {}
              }
            } catch {}
            const idx = tunnels.indexOf(t)
            if (idx >= 0) tunnels.splice(idx,1)
            await window.api.tunnelsSave(tunnels)
            renderTunnels()
          }
          colC.appendChild(startBtn); colC.appendChild(stopBtn); colC.appendChild(editBtn); colC.appendChild(delBtn)
          row.appendChild(colA); row.appendChild(colB); row.appendChild(colC)
          tunListEl.appendChild(row)
        }
      }

      tunCreateBtn.onclick = async () => {
        const selInfo0 = selectedId ? findNodeById(sessionTree, selectedId, null) : null
        const sessNode0 = selInfo0 && selInfo0.node && selInfo0.node.type==='session' ? selInfo0.node : null
        if (!sessNode0) { await showConfirmModal('Error', 'Select a session in the left tree first.', 'OK', ''); return }
        // Modal wizard
        const overlay = document.createElement('div'); overlay.className='modal-overlay'
        const modal = document.createElement('div'); modal.className='modal'
        const header = document.createElement('div'); header.className='modal-header'; header.textContent='Create Tunnel'
        const body = document.createElement('div'); body.className='modal-body'
        const step1 = document.createElement('div'); step1.style.display='flex'; step1.style.gap='8px'; step1.style.alignItems='center'
        step1.innerHTML = '<span>Local port</span>'
        const inLocal = document.createElement('input'); inLocal.className='input'; inLocal.placeholder='8080'; inLocal.value='8080'
        step1.appendChild(inLocal)
        const step2 = document.createElement('div'); step2.style.display='none'; step2.style.gap='8px'; step2.style.alignItems='center'
        step2.innerHTML = '<span>Remote port</span>'
        const inRemote = document.createElement('input'); inRemote.className='input'; inRemote.placeholder='80'; inRemote.value='80'
        step2.appendChild(inRemote)
        const step3 = document.createElement('div'); step3.style.display='none'; step3.style.gap='8px'; step3.style.alignItems='center'
        step3.innerHTML = '<span>Name (optional)</span>'
        const inName = document.createElement('input'); inName.className='input'; inName.placeholder='My tunnel'
        step3.appendChild(inName)
        body.appendChild(step1); body.appendChild(step2); body.appendChild(step3)
        const actions = document.createElement('div'); actions.className='modal-actions'
        const btnCancel = document.createElement('button'); btnCancel.className='btn'; btnCancel.textContent='Cancel'
        const btnNext = document.createElement('button'); btnNext.className='btn primary'; btnNext.textContent='Next'
        const btnCreate = document.createElement('button'); btnCreate.className='btn primary'; btnCreate.textContent='Create'; btnCreate.style.display='none'
        actions.appendChild(btnCancel); actions.appendChild(btnNext); actions.appendChild(btnCreate)
        modal.appendChild(header); modal.appendChild(body); modal.appendChild(actions); overlay.appendChild(modal); document.body.appendChild(overlay)

        let step = 1
        function update() {
          step1.style.display = step===1?'flex':'none'
          step2.style.display = step===2?'flex':'none'
          step3.style.display = step===3?'flex':'none'
          btnNext.style.display = step<3?'':'none'
          btnCreate.style.display = step===3?'':'none'
        }
        update()

        function close() { try { document.body.removeChild(overlay) } catch {} }
        btnCancel.onclick = close
        btnNext.onclick = () => { step = Math.min(3, step+1); update() }

        btnCreate.onclick = async () => {
        // Use selected session
        const selInfo = selectedId ? findNodeById(sessionTree, selectedId, null) : null
        const sessNode = selInfo && selInfo.node && selInfo.node.type==='session' ? selInfo.node : null
        if (!sessNode) { await showConfirmModal('Error', 'Select a session in the left tree first.', 'OK', ''); return }
        const remoteHost = (sessNode.session && (sessNode.session.host || sessNode.session.hostname)) || '127.0.0.1'
        const localPort = Number(inLocal.value || '0')
        const remotePort = Number(inRemote.value || '0')
        if (!localPort || !remotePort) { alert('Ports are required'); return }
        const name = (inName.value || '').trim()
        // Add tunnel inactive by default
        const entry = { id: genId('tun'), sessionId: sessNode.id, sessionCfg: sessNode.session, name, localHost:'127.0.0.1', localPort, remoteHost, remotePort, active:false }
        tunnels.push(entry)
        await window.api.tunnelsSave(tunnels)
        renderTunnels()
          close()
        }
      }

      // Load persisted tunnels
      async function loadTunnelsUI() {
        try {
          const res = await window.api.tunnelsLoad()
          tunnels = Array.isArray(res?.tunnels) ? res.tunnels : []
          renderTunnels()
        } catch {}
      }
      loadTunnelsUI()
      window.api.onTunnelsUpdated?.(() => loadTunnelsUI())
    </script>
  </body>
  </html>
